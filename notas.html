<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-11 lun 23:25 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notas del curso Machine Learning de Andrew Ng en Coursera</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Pablo Aguado" />
<meta name="description" content="Mis notas."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Notas del curso Machine Learning de Andrew Ng en Coursera</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9b1f582">1. Info</a></li>
<li><a href="#org41cc6a8">2. Ideas</a>
<ul>
<li><a href="#org6215d15">2.1. Enlaces</a></li>
</ul>
</li>
<li><a href="#org4d5ff58">3. Semana 1</a>
<ul>
<li><a href="#org7908d20">3.1. Introduction</a>
<ul>
<li><a href="#org4bdc274">3.1.1. Video: Welcome</a></li>
<li><a href="#orgdb32e83">3.1.2. Video: What is Machine Learning</a></li>
<li><a href="#org09e9b0e">3.1.3. Reading: What is Machine Learning?</a></li>
<li><a href="#orgbb05045">3.1.4. Video: Supervised Learning</a></li>
<li><a href="#org70ba0f7">3.1.5. Video: Unsupervised Learning</a></li>
</ul>
</li>
<li><a href="#orgde3cb88">3.2. Model and cost function</a>
<ul>
<li><a href="#org1da8047">3.2.1. Video: Model representation</a></li>
<li><a href="#orgc7dedeb">3.2.2. Reading: Model representation</a></li>
<li><a href="#orgf83b85a">3.2.3. Video: Cost function</a></li>
<li><a href="#orge04bb15">3.2.4. Reading: Cost function</a></li>
<li><a href="#orgec15577">3.2.5. Video: Cost function intuition I</a></li>
<li><a href="#orgac9e358">3.2.6. Reading: Cost function intuition I</a></li>
<li><a href="#org38e28f4">3.2.7. Video: Cost function intuition II</a></li>
<li><a href="#orgda78361">3.2.8. Reading: Cost function intuition II</a></li>
</ul>
</li>
<li><a href="#org80d8ef7">3.3. Parameter learning</a>
<ul>
<li><a href="#org1097968">3.3.1. Video: Gradient descent</a></li>
<li><a href="#org4388fc8">3.3.2. Reading: Gradient descent</a></li>
<li><a href="#orged18215">3.3.3. Video: Gradient descent intuition</a></li>
<li><a href="#orgc91afe5">3.3.4. Reading: Gradient descent intuition</a></li>
<li><a href="#org5cee9ad">3.3.5. Video: Gradient descent for linear regression</a></li>
<li><a href="#org624b9dc">3.3.6. Reading: Gradient descent for linear regression</a></li>
</ul>
</li>
<li><a href="#org06e4664">3.4. Linear Algebra review</a>
<ul>
<li><a href="#orgac18beb">3.4.1. Video: Matrix vector multiplication</a></li>
<li><a href="#org17fd262">3.4.2. Video: Matrix matrix multiplication</a></li>
<li><a href="#org2711361">3.4.3. Video: Inverse and transpose</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org92fc94b">4. Semana 2</a>
<ul>
<li><a href="#org3286aa8">4.1. Environment setup instructions</a></li>
<li><a href="#orgd218c58">4.2. Multivariate linear regression</a>
<ul>
<li><a href="#orgc690025">4.2.1. Video: Multivariate linear regression</a></li>
<li><a href="#org552cf93">4.2.2. Reading: multiple features</a></li>
<li><a href="#org9512b94">4.2.3. Video: Gradient descent for multiple features</a></li>
<li><a href="#org012a269">4.2.4. Reading: Gradient descent for multiple features</a></li>
<li><a href="#orgdee24b4">4.2.5. Video: Gradient descent in practice I - Feature scaling</a></li>
<li><a href="#orgd33f7af">4.2.6. Reading: Gradient descent in practice I - Feature scaling</a></li>
<li><a href="#orgcafa501">4.2.7. Video: Gradient descent in practice II - Learning rate</a></li>
<li><a href="#org1820d50">4.2.8. Reading: Gradient descent in practice II - Learning rate</a></li>
<li><a href="#org1d2e0ef">4.2.9. Video: Features and polynomial regression</a></li>
<li><a href="#org4ae9ddb">4.2.10. Reading: Features and polynomial regression</a></li>
</ul>
</li>
<li><a href="#org782530e">4.3. Computing parameters analitically</a>
<ul>
<li><a href="#org259c16d">4.3.1. Video: Normal equation</a></li>
<li><a href="#orgd703e2a">4.3.2. Reading: Normal equation</a></li>
<li><a href="#org7d11b78">4.3.3. Video: Normal equation noninvertibility</a></li>
<li><a href="#org32ab608">4.3.4. Reading: Normal equation noninvertibility</a></li>
</ul>
</li>
<li><a href="#orge6d72f4">4.4. Submitting programming assignments</a></li>
<li><a href="#org2719473">4.5. Review</a></li>
<li><a href="#org8b5796b">4.6. Octave/Matlab tutorial</a></li>
<li><a href="#org1222ea2">4.7. Review</a>
<ul>
<li><a href="#orga0e3243">4.7.1. Programming assignment 1: linear regression</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6744620">5. Semana 3</a>
<ul>
<li><a href="#orge5bbc1e">5.1. Classification and representation</a>
<ul>
<li><a href="#orge8f3cff">5.1.1. Classification</a></li>
<li><a href="#org47c5dbf">5.1.2. Hypothesis representation</a></li>
<li><a href="#orgb5319c1">5.1.3. Decision boundary</a></li>
</ul>
</li>
<li><a href="#org73a8e37">5.2. Logistic regression model</a>
<ul>
<li><a href="#org5319bdf">5.2.1. Cost function</a></li>
<li><a href="#orgc14bd2a">5.2.2. Simplified cost function and gradient descent</a></li>
<li><a href="#org69acf6e">5.2.3. Advanced optimization</a></li>
</ul>
</li>
<li><a href="#org379ef8b">5.3. Multiclass classification</a>
<ul>
<li><a href="#org386d0cf">5.3.1. Multiclass classification: one vs all</a></li>
</ul>
</li>
<li><a href="#org119a85e">5.4. Solving the problem of overfitting</a>
<ul>
<li><a href="#orga9df6f5">5.4.1. The problem of overfitting</a></li>
<li><a href="#org44c2e55">5.4.2. Cost function</a></li>
<li><a href="#org15c979c">5.4.3. Regularized linear regression</a></li>
<li><a href="#org983225c">5.4.4. Regularized logistic regression</a></li>
</ul>
</li>
<li><a href="#org0d023d8">5.5. Review</a>
<ul>
<li><a href="#org87e1283">5.5.1. Quiz: Regularization</a></li>
<li><a href="#org4bc9297">5.5.2. Programming assignment: logistic regression</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf624875">6. Semana 4</a>
<ul>
<li><a href="#org5cf4a99">6.1. Motivations</a>
<ul>
<li><a href="#org5f0b313">6.1.1. Non-linear hypotheses</a></li>
<li><a href="#orgecd3e2e">6.1.2. Neurons and the brain</a></li>
</ul>
</li>
<li><a href="#org41c5e56">6.2. Neural networks</a>
<ul>
<li><a href="#org96840d0">6.2.1. Model representation I</a></li>
<li><a href="#org0fa4c23">6.2.2. Model representation II</a></li>
</ul>
</li>
<li><a href="#orgcc4c775">6.3. Applications</a>
<ul>
<li><a href="#orge66a7bf">6.3.1. Examples and intuitions I</a></li>
<li><a href="#orga81a871">6.3.2. Examples and intuitions II</a></li>
<li><a href="#orgac7ee74">6.3.3. Multiclass classification</a></li>
</ul>
</li>
<li><a href="#orgb76efdc">6.4. Review</a>
<ul>
<li><a href="#org108ec1a">6.4.1. Quiz: Neural networks: representation</a></li>
<li><a href="#org37dcd8a">6.4.2. Programming assignment: multi-class classificatin and neural networks</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb1396d9">7. Semana 5</a>
<ul>
<li><a href="#org372733c">7.1. Cost function and backpropagation</a>
<ul>
<li><a href="#org471a024">7.1.1. Cost function</a></li>
<li><a href="#org5564f08">7.1.2. Backpropagation algorithm</a></li>
<li><a href="#orgbc0a3fa">7.1.3. Backpropagation intuition</a></li>
</ul>
</li>
<li><a href="#orgecf5c3a">7.2. Backpropagation in practice</a>
<ul>
<li><a href="#orgc3e46b7">7.2.1. Implementation note: unrolling parameters</a></li>
<li><a href="#orgfcef775">7.2.2. Gradient checking</a></li>
<li><a href="#org8ce714b">7.2.3. Random initialization</a></li>
<li><a href="#org5f15b42">7.2.4. Putting it together</a></li>
</ul>
</li>
<li><a href="#org23a1c5d">7.3. Applications of neural networks</a>
<ul>
<li><a href="#org0ce5617">7.3.1. Autonomous driving</a></li>
</ul>
</li>
<li><a href="#orgb708e12">7.4. Review</a>
<ul>
<li><a href="#orge454400">7.4.1. Quiz: Neural networks: learning</a></li>
<li><a href="#org7868e21">7.4.2. Programming assignment: neural network learning</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org946e9fd">8. Semana 6</a>
<ul>
<li><a href="#org96b0b20">8.1. Evaluating a learning algorithm</a>
<ul>
<li><a href="#orga0843ad">8.1.1. Deciding what to try next</a></li>
<li><a href="#orgf397965">8.1.2. Evaluating a hypothesis</a></li>
<li><a href="#orgac4a1ea">8.1.3. Model selection and train/validation/test sets</a></li>
</ul>
</li>
<li><a href="#orgbee5aeb">8.2. Bias vs variance</a>
<ul>
<li><a href="#org2946627">8.2.1. Diagnosing bias vs variance</a></li>
<li><a href="#org303d0ae">8.2.2. Regularization and bias/variance</a></li>
<li><a href="#org88af548">8.2.3. Learning curves</a></li>
<li><a href="#orgb78ab84">8.2.4. Deciding what to do next revisited</a></li>
</ul>
</li>
<li><a href="#org14c35ff">8.3. Review</a>
<ul>
<li><a href="#orgb4c63e9">8.3.1. Quiz: advice for applying machine learning</a></li>
<li><a href="#orgd842564">8.3.2. Programming assignment: regularized linear regression and bias/variance</a></li>
</ul>
</li>
<li><a href="#org5fe1c1c">8.4. Building a spam classifier</a>
<ul>
<li><a href="#org2f362f5">8.4.1. Prioritizing what to work on</a></li>
<li><a href="#org3d8f13f">8.4.2. Error analysis</a></li>
</ul>
</li>
<li><a href="#orgf3c678c">8.5. Handling skewed data</a>
<ul>
<li><a href="#org0eab9f7">8.5.1. Error metrics for skewed classes</a></li>
<li><a href="#orgf76bc14">8.5.2. Trading off precision and recall</a></li>
</ul>
</li>
<li><a href="#org53e9b73">8.6. Using large datasets</a>
<ul>
<li><a href="#org0877455">8.6.1. Data for machine learning</a></li>
</ul>
</li>
<li><a href="#orge0b59fa">8.7. Review</a>
<ul>
<li><a href="#org99a90a7">8.7.1. Quiz: machine learning system design</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbc17175">9. Semana 7</a>
<ul>
<li><a href="#org2379d94">9.1. Large margin classification</a>
<ul>
<li><a href="#orgd08433a">9.1.1. Optimization objective</a></li>
<li><a href="#org611eec5">9.1.2. Large margin intuition</a></li>
<li><a href="#org249e2c9">9.1.3. Mathematics behind large margin classification</a></li>
</ul>
</li>
<li><a href="#org37ab45e">9.2. Kernels</a>
<ul>
<li><a href="#org795a3d3">9.2.1. Kernels I</a></li>
<li><a href="#org9502002">9.2.2. Kernels II</a></li>
</ul>
</li>
<li><a href="#orgf6e6545">9.3. SVMs in practice</a>
<ul>
<li><a href="#orgad1eea0">9.3.1. Using an SVM</a></li>
</ul>
</li>
<li><a href="#org5d227d2">9.4. Review</a>
<ul>
<li><a href="#orgecd6ffe">9.4.1. Quiz: support vector machines</a></li>
<li><a href="#org36fdbf7">9.4.2. Programming assignmentL SVMs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org9b1f582" class="outline-2">
<h2 id="org9b1f582"><span class="section-number-2">1</span> Info</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li><a href="https://www.coursera.org/learn/machine-learning">https://www.coursera.org/learn/machine-learning</a></li>
<li><a href="https://www.coursera.org/learn/machine-learning/discussions/all/threads/v2YppY8FEeWIeBJxvl1elQ">Important notes for new ML students</a>
<ul class="org-ul">
<li>Hay más <i>test cases</i> en los Recursos del curso.</li>
<li><b>Hay que usar Octave &gt; 4.0.0</b></li>
<li><a href="https://learner.coursera.help/hc/en-us/articles/209818863-Coursera-Honor-Code">Cousera Honor Code</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org41cc6a8" class="outline-2">
<h2 id="org41cc6a8"><span class="section-number-2">2</span> Ideas</h2>
<div class="outline-text-2" id="text-2">
<p>
Ideas mías a lo largo del curso.
</p>

<ol class="org-ol">
<li>Probar <a href="https://github.com/google-research/google-research/blob/master/automl_zero/README.md">AutoML-Zero</a>.</li>
<li>Buscar clusters en espacios transformados y muy transformados. Ej: Fourier, Fourier de Fourier, Cepstrum&#x2026;</li>
</ol>
</div>

<div id="outline-container-org6215d15" class="outline-3">
<h3 id="org6215d15"><span class="section-number-3">2.1</span> Enlaces</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li><a href="http://www.deeplearningbook.org/">http://www.deeplearningbook.org/</a></li>
<li><a href="http://ufldl.stanford.edu/tutorial/">http://ufldl.stanford.edu/tutorial/</a>  Deep Learning Tutorial</li>
<li><a href="https://developers.google.com/machine-learning/crash-course">https://developers.google.com/machine-learning/crash-course</a></li>
<li><a href="https://deeplearning.mit.edu/">https://deeplearning.mit.edu/</a></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org4d5ff58" class="outline-2">
<h2 id="org4d5ff58"><span class="section-number-2">3</span> Semana 1</h2>
<div class="outline-text-2" id="text-3">
<p>
Intro, regresión lineal, repaso de Álgebra.
</p>


<ul class="org-ul">
<li><a href="https://www.coursera.org/learn/machine-learning/discussions/weeks/1/threads/hAp4LT1SEeaL_xIEq4QdBw">FAQ de la semana 1</a></li>
</ul>
</div>

<div id="outline-container-org7908d20" class="outline-3">
<h3 id="org7908d20"><span class="section-number-3">3.1</span> Introduction</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org4bdc274" class="outline-4">
<h4 id="org4bdc274"><span class="section-number-4">3.1.1</span> Video: Welcome</h4>
</div>

<div id="outline-container-orgdb32e83" class="outline-4">
<h4 id="orgdb32e83"><span class="section-number-4">3.1.2</span> Video: What is Machine Learning</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>Los algoritmos más importantes son el aprendizaje supervisado y el aprendizaje no supervisado. Es esta además la clasificación más general de algoritmos.
<ul class="org-ul">
<li>Otros son el aprendizaje por refuerzo y los sistemas de recomendación.</li>
</ul></li>
<li>Hay que aprender las herramientas, pero <b>es muy importante saber cómo y cuándo usarlas</b>.</li>
<li>Sea una máquina que debe hacer una tarea T, con un desempeño P y que la exponemos a experiencias (instancias) E de esa tarea T. Se dice que la computadora aprende si su desempeño P en la tarea T <i>aumenta proporcionalmente a la cantidad de experiencias E</i>.</li>
<li>Otra definición de aprendizaje automático es la capacidad (de la computadora) de aprender a resolver problemas para los que no fue programada. ~</li>
</ul>
</div>
</div>

<div id="outline-container-org09e9b0e" class="outline-4">
<h4 id="org09e9b0e"><span class="section-number-4">3.1.3</span> Reading: What is Machine Learning?</h4>
</div>

<div id="outline-container-orgbb05045" class="outline-4">
<h4 id="orgbb05045"><span class="section-number-4">3.1.4</span> Video: Supervised Learning</h4>
<div class="outline-text-4" id="text-3-1-4">
<ul class="org-ul">
<li>En el aprendizaje supervisado, le mostramos al programa ejemplos de entradas y sus correspondientes salidas/respuestas correctas. Ya sabemos cómo son las respuestas corectas; tenemos la idea de que hay una relación entre las entradas y las salidas. Dado un conjunto de entradas y salidas, intentamos obtener un modelo que permita predecir/inferir las salidas a nuevos datos de entrada.</li>
<li>Los problemas de aprendizaje supervisado se clasifican en problemas de regresión y de clasificación:
<ul class="org-ul">
<li>Problema de <b>regresión</b> si el conjunto imagen es continuo. La salida es una variable numérica.</li>
<li>Problema de <b>clasificación</b> si el conjunto imagen es discreto. La salida es una variable categórica.</li>
</ul></li>
<li>Los algoritmos de Máquinas de Vector Soporte permiten <i><b>infinitos</b></i> valores de entrada.</li>
</ul>
</div>

<ol class="org-ol">
<li><a id="org50263b9"></a><span class="todo TODO">TODO</span> Leer <a href="https://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression">https://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression</a><br /></li>

<li><a id="org37f79ee"></a><span class="todo TODO">TODO</span> Leer <a href="https://datascience.stackexchange.com/questions/25298/how-to-know-when-to-treat-a-problem-as-a-classification-task-or-a-regression-tas">https://datascience.stackexchange.com/questions/25298/how-to-know-when-to-treat-a-problem-as-a-classification-task-or-a-regression-tas</a><br /></li>
</ol>
</div>

<div id="outline-container-org70ba0f7" class="outline-4">
<h4 id="org70ba0f7"><span class="section-number-4">3.1.5</span> Video: Unsupervised Learning</h4>
<div class="outline-text-4" id="text-3-1-5">
<ul class="org-ul">
<li>En el aprendizaje no supervisado, le damos datos al programa con la intención de encontrar estructuras subyacentes, patrones.</li>
<li>Un ejemplo típico es el <i>clustering</i> o agrupamiento de datos.</li>
<li>En el ejemplo de sonido Cocktail Party, según <a href="https://www.coursera.org/learn/machine-learning/discussions/weeks/1/threads/hAp4LT1SEeaL_xIEq4QdBw">FAQ de la semana 1</a>, lo que usan es <i>Principal Component Analysis, PCA, a mathematical trick that takes two sets of correlated data, and returns two new sets of data that are not correlated.</i> No lo había visto así antes, creo&#x2026;</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgde3cb88" class="outline-3">
<h3 id="orgde3cb88"><span class="section-number-3">3.2</span> Model and cost function</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Vemos la regresión lineal como primer algoritmo de aprendizaje supervisado.
</p>
</div>

<div id="outline-container-org1da8047" class="outline-4">
<h4 id="org1da8047"><span class="section-number-4">3.2.1</span> Video: Model representation</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Un poco de nomenclatura:
</p>

<ul class="org-ul">
<li>\(m\): cantidad de ejemplos de entrenamiento.</li>
<li>\(\vec{x}\): entradas / descriptores / <i>features</i></li>
<li>\(\vec{y}\): salidas. \(\hat{\vec{y}}\) son las salidas estimadas.</li>
<li>\(h_\theta\): función de hipótesis, de estimación. Tiene parámetros \(\vec{\theta}\). Entonces tenemos que \( \hat{y}^{(i)} = h_\theta(x^{(i)}) = h(x,\theta) \)</li>
<li>\(x^{(i)}\): entrada $i$-ésima del vector de entradas, con índices empezando en 1.
<ul class="org-ul">
<li>\((x^{(i)},y^{(i)})\) es un ejemplo de entrenamiento.</li>
</ul></li>
<li>Para regresión lineal de una variable tenemos entonces</li>
</ul>
<p>
\[ \hat{y}^{(i)} = h_\theta(x^{(i)}) = \theta_0 + \theta_1 * x^{(i)} \]
</p>
</div>
</div>

<div id="outline-container-orgc7dedeb" class="outline-4">
<h4 id="orgc7dedeb"><span class="section-number-4">3.2.2</span> Reading: Model representation</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li>\(X\): el espacio de los valores de entrada.</li>
<li>\(Y\): el espacio de los valores de salida.</li>
<li>El objetivo del aprendizaje supervisado es encontrar una función \(h: X \rightarrow Y\) que sea buena prediciendo salidas a partir de entradas.</li>
</ul>
</div>
</div>

<div id="outline-container-orgf83b85a" class="outline-4">
<h4 id="orgf83b85a"><span class="section-number-4">3.2.3</span> Video: Cost function</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Formalizamos el problema del aprendizaje como la minimización de una función de costo \(J(\vec{\theta})\). La función de costo habitual y recomendada para problemas de regresión lineal es el <b>error cuadrático medio</b> (<a href="https://en.wikipedia.org/wiki/Mean_squared_error"><i>Mean Squared Error</i></a> o <i>Mean Squared Deviation</i>).
</p>

<p>
Para un predictor como lo es \(h_\theta\), el MSE se define como
\[ MSE = \frac{1}{N} (\sum_{1}^{N}Y_i - \hat{Y}_i )^2\]
</p>

<p>
En nuestro caso vamos a definir a la función de costo para este problema de regresión lineal univariable como
</p>

<p>
\[ J(\theta_0 , \theta_1) = \frac{1}{2m} \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} )^2  \]
\[ J(\theta_0 , \theta_1) =  \frac{1}{2m} \sum_{i=1}^m( \theta_0 + \theta_1 * x^{(i)} - y^{(i)} )^2 \]
</p>

<ul class="org-ul">
<li>El factor \(1/2\) es para ahorrar cálculos, puesto que en redes neuronales al hacer <i>backpropagation</i> o <i>gradient descent</i> hay que derivar esta función de error y entonces con este \(1/2\) simplificamos el \(2\) de la derivada del cuadrado.</li>
</ul>

<p>
La optimización es entonces encontrar los parámetros \(\theta\) que minimizan la función de costo:
\[ \underset{\theta_0 , \theta_1}{\text{min}}  J(\theta_0 , \theta_1)\]
</p>

<hr />

<p>
<i>En las notas del curso encontramos la forma matricial, que luego usamos para hacer descenso por el gradiente de forma matricial. Lo pongo acá por completitud</i>.
</p>

<p>
MSE: \[ J(\theta) = \frac{1}{2m} (X\times\theta-Y)^T(X\times\theta-Y)  \]
</p>

<p>
El producto implica la sumatoria y el cuadrado elemento a elemento.
</p>

<hr />
</div>
</div>

<div id="outline-container-orge04bb15" class="outline-4">
<h4 id="orge04bb15"><span class="section-number-4">3.2.4</span> Reading: Cost function</h4>
</div>

<div id="outline-container-orgec15577" class="outline-4">
<h4 id="orgec15577"><span class="section-number-4">3.2.5</span> Video: Cost function intuition I</h4>
</div>

<div id="outline-container-orgac9e358" class="outline-4">
<h4 id="orgac9e358"><span class="section-number-4">3.2.6</span> Reading: Cost function intuition I</h4>
</div>

<div id="outline-container-org38e28f4" class="outline-4">
<h4 id="org38e28f4"><span class="section-number-4">3.2.7</span> Video: Cost function intuition II</h4>
</div>

<div id="outline-container-orgda78361" class="outline-4">
<h4 id="orgda78361"><span class="section-number-4">3.2.8</span> Reading: Cost function intuition II</h4>
<div class="outline-text-4" id="text-3-2-8">
<p>
De <a href="https://es.wikipedia.org/wiki/Isol%C3%ADnea">isolíneas / curvas de nivel</a>.
</p>
</div>
</div>
</div>


<div id="outline-container-org80d8ef7" class="outline-3">
<h3 id="org80d8ef7"><span class="section-number-3">3.3</span> Parameter learning</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-org1097968" class="outline-4">
<h4 id="org1097968"><span class="section-number-4">3.3.1</span> Video: Gradient descent</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
El descenso por el gradiente es un algoritmo de optimización que vamos a usar (entre otras cosas) para minimizar la función de costo.
</p>

<p>
Hacer \[ \vec{\theta}[n+1] := \vec{\theta}[n] - \alpha \frac{\partial J(\vec{\theta})}{\partial\theta}  \]
</p>

<p>
(expresado de otra manera)
</p>

<p>
\[ {\theta}_j[n+1] := {\theta}_j[n] - \alpha \frac{\partial J(\vec{\theta})}{\partial\theta}  \]
</p>

<p>
Hasta la convergencia de \(\vec{\theta}\), equivalente a la convergencia de \(J(\vec{\theta})\):
</p>

<p>
\[  \vec{\theta}[n] - \vec{\theta}[n-1] < \vec{\epsilon} \]
\[ J(\vec{\theta}[n]) - J(\vec{\theta}[n-1])  < \epsilon  \]
</p>

<ul class="org-ul">
<li>Nomenclatura: usamos \(:=\) como operador de asignación.</li>
<li>\(\alpha\) es la tasa de aprendizaje o <i>learning rate</i> del algoritmo.</li>
</ul>

<p>
Para calcular la derivada hacemos derivadas parciales. Actualizamos los parámetros simultáneamente en cada paso. Si actualizamos de a uno y recalculamos estamos haciendo otro algoritmo, que probablemente también converja pero es distinto.
</p>

<p>
Cuando la función de costo es el error cuadrático medio (<i>MSE</i>), la fórmula de actualización queda:
</p>

<p>
\[ \theta_j[n+1] := {\theta}_j[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)}  \]
</p>

<ul class="org-ul">
<li>El primer termino de la sumatoria es la magnitud y dirección del error.</li>
<li>El segundo término de la sumatoria es la sensibilidad de J respecto al parámetro, y resulta ser igual a la magnitud del descriptor asociado a ese parámetro.</li>
</ul>

<hr />

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=WnqQrPNYz5Q">Un video de <i>gradient descent</i> sugerido en las notas del curso</a>.</li>
</ul>
</div>
</div>

<div id="outline-container-org4388fc8" class="outline-4">
<h4 id="org4388fc8"><span class="section-number-4">3.3.2</span> Reading: Gradient descent</h4>
</div>

<div id="outline-container-orged18215" class="outline-4">
<h4 id="orged18215"><span class="section-number-4">3.3.3</span> Video: Gradient descent intuition</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>Si \(\alpha\) es muy grande, el algoritmo puede oscilar o incluso diverger.</li>
<li>Si \(\alpha\) es muy chica, puede tardar mucho en converger.</li>
<li>Con \(\alpha\) fija, los "pasos" que da el algoritmo son cada vez más chicos a medida que la función de costo se aproxima a un mínimo local.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc91afe5" class="outline-4">
<h4 id="orgc91afe5"><span class="section-number-4">3.3.4</span> Reading: Gradient descent intuition</h4>
</div>

<div id="outline-container-org5cee9ad" class="outline-4">
<h4 id="org5cee9ad"><span class="section-number-4">3.3.5</span> Video: Gradient descent for linear regression</h4>
<div class="outline-text-4" id="text-3-3-5">
<p>
Dice Andrew cerca del minuto 4:40:
</p>

<blockquote>
<p>
But, it turns out that that the cost function for
linear regression is always going to be a bow shaped function like this.
The technical term for this is that this is called a convex function.
</p>
</blockquote>

<p>
¿Por qué?
</p>

<ul class="org-ul">
<li>La función de costo \(J(\vec{\theta})\) es el error cuadrático medio (MSE).</li>
<li>El MSE es cuadrático respecto a los parámetros siempre y cuando estos sean lineales, de grado 1. <b>La función de hipótesis debe ser lineal respecto a los parámetros para que la función de costo sea cuadrática</b>.
<ul class="org-ul">
<li>Sea por ejemplo \[ h(x,y) =  a.x^2 + b.y^2 - c.x^2 y^2 \]. Esta función tiene más de un mínimo.</li>
</ul></li>
</ul>


<div class="figure">
<p><img src="imgs/001-01-nolineal.gif" alt="001-01-nolineal.gif" />
</p>
</div>

<ul class="org-ul">
<li>Su MSE quedaría algo como \[ x^4 + 2 x^2 y^2 - 2 x^4 y^2 + y^4 - 2 x^2 y^4 + x^4 y^4  \] (sólo <a href="https://www.wolframalpha.com/input/?i=%28x%5E2+%2B+y%5E2+-+x%5E2y%5E2%29%5E2">la elevé al cuadrado</a>)</li>
</ul>


<div class="figure">
<p><img src="imgs/001-02-nolineal-cuadrado.gif" alt="001-02-nolineal-cuadrado.gif" />
</p>
</div>

<hr />

<p>
Hay otras formas de estimar los parámetros (regresores). Una de ellas es el método de los mínimos cuadrados (<a href="https://en.wikipedia.org/wiki/Ordinary_least_squares">/Ordinary Least Squares</a>/). El descenso por el gradiente es más fácil de computar que OLS, en el caso de datasets grandes.
</p>

<p>
En realidad todo lo que vimos es descenso por el gradiente por lotes, o <b><i>batch gradient descent</i></b>, que es cuando la función de costo se optimiza usando todas las entradas disponibles. Esto es costoso.
</p>
</div>



<ol class="org-ol">
<li><a id="orgf3961a9"></a><span class="todo TODO">TODO</span> Leer más de <a href="https://en.wikipedia.org/wiki/Linear_regression">regresión lineal</a><br /></li>
</ol>



<li><a id="org5fe602d"></a>Regresión lineal<br /></li>
</ol>
</div>



<div id="outline-container-org624b9dc" class="outline-4">
<h4 id="org624b9dc"><span class="section-number-4">3.3.6</span> Reading: Gradient descent for linear regression</h4>
</div>
</div>

<div id="outline-container-org06e4664" class="outline-3">
<h3 id="org06e4664"><span class="section-number-3">3.4</span> Linear Algebra review</h3>
<div class="outline-text-3" id="text-3-4">
</div>
<div id="outline-container-orgac18beb" class="outline-4">
<h4 id="orgac18beb"><span class="section-number-4">3.4.1</span> Video: Matrix vector multiplication</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>Más adelante vamos a ver por qué es mejor vectorizar calculos en lugar de iterar.</li>
<li>Hace un truco interesante que es incluir a la ordenada al origen dentro del vector de parámetros &#x2014;en realidad está bien, es un parámetr calculado&#x2014;, y luego introduce una columna de \(1\)s en la matriz de entradas.
<ul class="org-ul">
<li>La alternativa es sumar la columna aparte. \(A*X + B\)</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org17fd262" class="outline-4">
<h4 id="org17fd262"><span class="section-number-4">3.4.2</span> Video: Matrix matrix multiplication</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>Acá hace el mismo truco pero para hacer varias predicciones a la vez: usa varios modelos y varias entradas.</li>
</ul>
</div>
</div>

<div id="outline-container-org2711361" class="outline-4">
<h4 id="org2711361"><span class="section-number-4">3.4.3</span> Video: Inverse and transpose</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
Interesante:
</p>
<blockquote>
<p>
But the intuition if you want is that you can think of matrices as not have an inverse that is somehow too close to zero in some sense.
</p>
</blockquote>

<ul class="org-ul">
<li>Las matrices que no tienen inversa son matrices <i>singulares</i> o <i>degeneradas</i>.
<ul class="org-ul">
<li>Asumo que se refiere a matrices cuadradas, que podrían tener inversa.</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org92fc94b" class="outline-2">
<h2 id="org92fc94b"><span class="section-number-2">4</span> Semana 2</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org3286aa8" class="outline-3">
<h3 id="org3286aa8"><span class="section-number-3">4.1</span> Environment setup instructions</h3>
</div>

<div id="outline-container-orgd218c58" class="outline-3">
<h3 id="orgd218c58"><span class="section-number-3">4.2</span> Multivariate linear regression</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-orgc690025" class="outline-4">
<h4 id="orgc690025"><span class="section-number-4">4.2.1</span> Video: Multivariate linear regression</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
En la regresión lineal multivariable o regresión lineal múltiple, tenemos varios valores de entrada o descriptores. Para tener una notación más compacta y conveniente, vamos a definir:
</p>
<ul class="org-ul">
<li>\(\theta_0=1\) ;</li>
<li>\(n\) es la cantidad de entradas, descriptores;</li>
<li>vamos a usar \(\vec{\theta}\) con índice \(0\);</li>
<li>y \(\vec{\theta}_j^{(i)}\) es el elemento j-ésimo del ejemplo i-ésimo.</li>
</ul>

<p>
Entonces \(\vec{\theta}\) tiene \(n+1\) elementos y  \[ \vec{\theta} = 1 + \theta_1 + \theta_2 + \dots + \theta_n  \]
</p>


<p>
Y luego \[ \vec{h_\theta}(\vec{x}) = \vec{\theta}^T \cdot \vec{x}  = \vec{x}^T \cdot \vec{\theta}  \]
</p>

<ul class="org-ul">
<li>Intuición para el ejemplo de estimar el precio de un inmueble: \(\theta_0\) es el precio base.</li>
</ul>

<hr />

<p>
<i>En <a href="#org259c16d">4.3.1</a> se introduce notación matricial que luego en el ejercicio 1 usamos para expresar todo de forma vectorizada. Dejo todo acá para más completitud</i>.
</p>

<p>
\[ \hat{Y}(&theta;,X) = X &theta;  ]\
</p>

<hr />
</div>
</div>

<div id="outline-container-org552cf93" class="outline-4">
<h4 id="org552cf93"><span class="section-number-4">4.2.2</span> Reading: multiple features</h4>
</div>

<div id="outline-container-org9512b94" class="outline-4">
<h4 id="org9512b94"><span class="section-number-4">4.2.3</span> Video: Gradient descent for multiple features</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
La regla de actualización era:
</p>

<p>
\[ \vec{\theta}[n+1] := \vec{\theta}[n] - \alpha \frac{\partial J(\vec{\theta})}{\partial\theta}  \]
</p>

<p>
Y para cuando la función de costo es el error cuadrático medio (MSE), queda (para actualización con <b>todos los \(m\) ejemplos</b>):
</p>

<p>
\[ \theta_j[n+1] := {\theta}_j[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)}  \]
</p>

<ul class="org-ul">
<li>Puedo ver el factor de avance luego de \(\alpha\) como el aporte al error medio que hizo el descriptor \(x_j\) .
<ul class="org-ul">
<li>El producto vectorial y la resta son el error medio para ese vector de entrada.</li>
<li>El factor \(x_j\) es el aporte de ese elemento, en esa dirección.
<ul class="org-ul">
<li>La dirección final es la suma vectorial de los elementos.</li>
</ul></li>
</ul></li>
</ul>

<hr />

<p>
<i>La versión vectorizada/matricial del algoritmo está en las notas del curso y después la usamos en el ejercicio de programación 1. La dejo acá por completitud</i>.
</p>

<p>
\[ \theta_{n \times 1}[i+1] = \theta_{n \times 1}[i] - \frac{\alpha}{m} X_{m \times n}^T (X_{m \times n} \theta_{n \times 1} - Y_{m \times 1} )_{m \times 1} \]
\[ \theta_{}[i+1] = \theta[i] - \frac{\alpha}{m} X^T (X \theta - Y) \]
</p>

<hr />
</div>

<ol class="org-ol">
<li><a id="org2d6b79a"></a><span class="todo TODO">TODO</span> EL ERROR ES MAYPR CUANDO HAY CORRELACIÓN ENTRE DESCRIPTORES Y PARÁMETROS.<br /></li>
</ol>
</div>

<div id="outline-container-org012a269" class="outline-4">
<h4 id="org012a269"><span class="section-number-4">4.2.4</span> Reading: Gradient descent for multiple features</h4>
</div>

<div id="outline-container-orgdee24b4" class="outline-4">
<h4 id="orgdee24b4"><span class="section-number-4">4.2.5</span> Video: Gradient descent in practice I - Feature scaling</h4>
<div class="outline-text-4" id="text-4-2-5">
<ul class="org-ul">
<li>Al parecer, el algoritmo de descenso por el gradiente converge <b>bastante más rápidamente</b> si los descriptores están en el mismo orden de magnitud.
<ul class="org-ul">
<li>Andrew propone que estén <i>más o menos</i> en el rango \(-3 < x_j < 3\) y duda si \(-\frac{1}{3} < x < \frac{1}{3}\)</li>
</ul></li>
<li>Para esto se suele normalizar cada descriptor respecto al rango de sí mismo en la muestra (los m ejemplos de entrada) o respecto a la desviación estándar. Esto se llama <b><i>feature scaling</i></b>.</li>
<li>Otra práctica habitual es centrar en cero los valores, para lo cual se resta la media de la muestra. Esto se llama <b><i>mean normalization</i></b>.</li>
</ul>
</div>

<ol class="org-ol">
<li><a id="org1ec3a8a"></a>Más de feature scaling y mean normalization<br />
<div class="outline-text-5" id="text-4-2-5-1">
<p>
De la ecuación de actualización de los parámetros de la ecuación de hipótesis
infiero que el vector se mueve <span class="underline">más rápidamente</span> en dirección de los parámetros
más grandes. Sin embargo en <a href="#orgd33f7af">4.2.6</a> dice:
</p>

<blockquote>
<p>
This is because θ will descend quickly on small ranges and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven.
</p>
</blockquote>
</div>

<ol class="org-ol">
<li><a id="orgfb4a3c0"></a><span class="done DONE">DONE</span> Averiguar más de esto. ¿Por qué se hace? ¿Tienen que ser de la misma magnitud o ser chicos?<br />
<div class="outline-text-7" id="text-4-2-5-1-0-1">
<ul class="org-ul">
<li>Ver <a href="https://www.robertoreif.com/blog/2017/12/21/importance-of-feature-scaling-in-data-modeling-part-2">https://www.robertoreif.com/blog/2017/12/21/importance-of-feature-scaling-in-data-modeling-part-2</a></li>
<li>Ver <a href="https://math.stackexchange.com/questions/2341704/feature-scalings-effect-on-gradient-descent">https://math.stackexchange.com/questions/2341704/feature-scalings-effect-on-gradient-descent</a></li>
</ul>

<p>
Estaba entendiendo mal las curvas de nivel. El eje corto de las elipses es el asociado a los descriptores más grandes, con más rango. Son curvas de nivel de \(J(\theta)\), no de \(J(x)\).  Ahora si estoy de acuerdo.
</p>

<p>
En regresión lineal (quizás puedo generalizarlo a cualquiera) <b>los parámetros tienen rangos "inversos" a los de los descriptores que multiplican</b>. Si un descriptor tiene un rango grande, entonces su parámetro asociado va a tener un rango chico.
</p>

<p>
<span class="underline">Se podría solucionar también con learning rates diferenciados: más grandes para los descriptores de más rango, más chicos para los de menos rango.</span>
</p>

<p>
¡Lo que dice en <a href="#orgd33f7af">4.2.6</a> está mal expresado entonces!
</p>
</div>
</li>

<li><a id="org1c56c43"></a><span class="todo TODO">TODO</span> Corregir <a href="https://math.stackexchange.com/questions/2341704/feature-scalings-effect-on-gradient-descent">https://math.stackexchange.com/questions/2341704/feature-scalings-effect-on-gradient-descent</a><br /></li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-orgd33f7af" class="outline-4">
<h4 id="orgd33f7af"><span class="section-number-4">4.2.6</span> Reading: Gradient descent in practice I - Feature scaling</h4>
</div>


<div id="outline-container-orgcafa501" class="outline-4">
<h4 id="orgcafa501"><span class="section-number-4">4.2.7</span> Video: Gradient descent in practice II - Learning rate</h4>
<div class="outline-text-4" id="text-4-2-7">
<ul class="org-ul">
<li>Si la función de costo \(J(\vec{\theta})\) diverge u oscila, entonces mi tasa de aprendizaje \(\alpha\) es muy grande. Si es muy chica, converge lentamente.</li>
<li>Puedo verlo graficando la función de costo.</li>
<li>Elegir el valor de \(\alpha\) es, a priori, por prueba y error. <b><i>¿Habrá heurísticas para determinar un buen valor inicial?</i></b></li>
<li>La condición de convergencia también suele depender del problema. Andrew habla de valores absolutos&#x2026; <b><i>¿por qué no usar un \(\epsilon\) relativo?</i></b></li>
</ul>
</div>
</div>

<div id="outline-container-org1820d50" class="outline-4">
<h4 id="org1820d50"><span class="section-number-4">4.2.8</span> Reading: Gradient descent in practice II - Learning rate</h4>
</div>


<div id="outline-container-org1d2e0ef" class="outline-4">
<h4 id="org1d2e0ef"><span class="section-number-4">4.2.9</span> Video: Features and polynomial regression</h4>
</div>

<div id="outline-container-org4ae9ddb" class="outline-4">
<h4 id="org4ae9ddb"><span class="section-number-4">4.2.10</span> Reading: Features and polynomial regression</h4>
<div class="outline-text-4" id="text-4-2-10">
<ul class="org-ul">
<li>La regresión lineal es ajustar un modelo lineal, de grado 1, una combinación lineal entre las entradas y parámetros.</li>
<li>Podemos ajustar modelos no lineales como hipótesis si codificamos estas no linealidades dentro de los descriptores. Por ejemplo, para el caso de la estimación de precios de casas, un posible descriptor podría ser el cuadrado del área, y ahí estamos incluyendo algo cuadrático en el modelo.</li>
<li>Al incluir las no linealidades en los descriptores, pero todavía usando los parámetros como multiplicadores de orden 1, podemos seguir usando el descenso por el gradiente para optimizar.</li>
<li>Andrew habla también de usar relaciones entre entradas básicas para construir otras entradas. Por ejemplo, el producto de dos descriptores hace un nuevo descriptor que codifica otra relación.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org782530e" class="outline-3">
<h3 id="org782530e"><span class="section-number-3">4.3</span> Computing parameters analitically</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-org259c16d" class="outline-4">
<h4 id="org259c16d"><span class="section-number-4">4.3.1</span> Video: Normal equation</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>Otra forma de optimizar la regresión lineal es resolverla analíticamente con el método de los <a href="https://en.wikipedia.org/wiki/Least_squares">mínimos cuadrados</a> <a href="https://en.wikipedia.org/wiki/Linear_least_squares">lineales</a> / ecuación normal. Esto da la solución óptima (que existe porque hemos dicho que para regresión lineal es un espacio de búsqueda cónvexo con un solo mínimo).</li>
</ul>

<p>
\[  \vec{\theta} = ( X^T \times X )^{-1} \times X^T \times \vec{y}   \]
</p>

<p>
\[ X = \left[  x^{(i)}  \right]  \]
</p>

<ul class="org-ul">
<li>A \(X\) la llamamos <b><i>matriz de diseño</i></b>. Cada fila es un ejemplo, y tiene tamaño $m &times; n+1 $</li>

<li>La complejidad de invertir una matriz es \(O(n^3)\) y esto se pone lento para \(n > 10^5\). La complejidad del descenso por el gradiente, en cambio, es de \(O(k \cdot n^2)\).</li>

<li>\(( X^T \times X )^{-1} \times X^T = X^{+}\) es la <span class="underline"><a href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse">pseudoinversa</a></span> de \(X\), y el método de mínimos cuadrados no es más que una solución (óptima en el sentido del error cuadrático) de un sistema de ecuaciones sobredeterminado.

<ul class="org-ul">
<li>La pseudoinversa se puede calcular con <i>Singular Value Decomposition</i> o Descomposición QR, por ejemplo.</li>

<li>La regresión por mínimos cuadrados asume muchas cosas que no necesariamente siempre se cumplen. Ver la <a href="https://en.wikipedia.org/wiki/Robust_regression">regresión robusta</a> como alternativa.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgd703e2a" class="outline-4">
<h4 id="orgd703e2a"><span class="section-number-4">4.3.2</span> Reading: Normal equation</h4>
</div>

<div id="outline-container-org7d11b78" class="outline-4">
<h4 id="org7d11b78"><span class="section-number-4">4.3.3</span> Video: Normal equation noninvertibility</h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
Si \(( X^T \times X )\) no es invertible, entonces puede haber 2 problemas:
</p>

<ol class="org-ol">
<li>El sistema esta subdeterminado. Faltan ejemplos, \(m < n\) / tenemos muchos descriptores.
<ul class="org-ul">
<li>Después vamos a ver que se soluciona con <i>regularización</i>.</li>
</ul></li>
<li>Algunos descriptores están muy correlacionados / son linealmente dependientes.</li>
</ol>

<p>
Si no es invertible naturalmente (es singular o degenerada) igual se puede invertir con la pseudoinversa. Igual esto no sería problema si hubiésemos usado la pseudoinversa desde un principio en lugar de estar haciéndolo manualmente. Y, nuevamente, seguro hay métodos más robustos (aunque no hay que dejar de hacer análisis de la información con la que contamos).
</p>
</div>
</div>

<div id="outline-container-org32ab608" class="outline-4">
<h4 id="org32ab608"><span class="section-number-4">4.3.4</span> Reading: Normal equation noninvertibility</h4>
</div>
</div>


<div id="outline-container-orge6d72f4" class="outline-3">
<h3 id="orge6d72f4"><span class="section-number-3">4.4</span> Submitting programming assignments</h3>
</div>

<div id="outline-container-org2719473" class="outline-3">
<h3 id="org2719473"><span class="section-number-3">4.5</span> Review</h3>
</div>

<div id="outline-container-org8b5796b" class="outline-3">
<h3 id="org8b5796b"><span class="section-number-3">4.6</span> Octave/Matlab tutorial</h3>
<div class="outline-text-3" id="text-4-6">
<div class="org-src-container">
<pre class="src src-octave"><span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">Para ver una matriz/vector como p&#237;xeles con color</span>
A <span style="color: #4f97d7;">=</span> magic<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">9</span><span style="color: #4f97d7;">)</span>
figure
imagesc<span style="color: #4f97d7;">(</span>A<span style="color: #4f97d7;">)</span>
colorbar
colormap gray
</pre>
</div>
</div>
</div>


<div id="outline-container-org1222ea2" class="outline-3">
<h3 id="org1222ea2"><span class="section-number-3">4.7</span> Review</h3>
<div class="outline-text-3" id="text-4-7">
</div>
<div id="outline-container-orga0e3243" class="outline-4">
<h4 id="orga0e3243"><span class="section-number-4">4.7.1</span> Programming assignment 1: linear regression</h4>
<div class="outline-text-4" id="text-4-7-1">
<ul class="org-ul">
<li>Mi gradient descent convergía pero no al mismo resultado exacto, y más rápida o lentamente. Me faltaba el factor \(1/m\).</li>
<li>Armé una versión vectorizada del gradient descent pero es distinta a la propuesta:</li>
</ul>

<p>
La mía:
</p>

<ul class="org-ul">
<li>usé \(n\) como la longitud de \(\theta\), incluyendo los \(1\)s.</li>
</ul>

<div class="org-src-container">
<pre class="src src-octave">M <span style="color: #4f97d7;">=</span> length<span style="color: #4f97d7;">(</span>y<span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span> <span style="color: #2aa1ae; background-color: #292e34;">% number of training examples</span>
N <span style="color: #4f97d7;">=</span> length<span style="color: #4f97d7;">(</span>theta<span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>
error <span style="color: #4f97d7;">=</span> <span style="color: #4f97d7;">(</span>X <span style="color: #4f97d7;">*</span> theta<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">-</span> y<span style="color: #4f97d7;">;</span>  <span style="color: #2aa1ae; background-color: #292e34;">% Mx1</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">ponderated_error = repmat(error, [1, N]) .* X;  % MxN</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">ponderated_error = error * ones(1,n) * X  % MxN, equivale al broadcasting</span>
ponderated_error <span style="color: #4f97d7;">=</span> error <span style="color: #4f97d7;">.*</span> X<span style="color: #4f97d7;">;</span>  <span style="color: #2aa1ae; background-color: #292e34;">% Broadcasting. MxN</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">gradient = sum(ponderated_error,1);  % 1xN</span>
gradient <span style="color: #4f97d7;">=</span> ones<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">,</span>M<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> ponderated_error<span style="color: #4f97d7;">;</span>  <span style="color: #2aa1ae; background-color: #292e34;">% 1xN, equivalente a la sumatoria</span>
theta <span style="color: #4f97d7;">=</span> theta <span style="color: #4f97d7;">-</span> <span style="color: #4f97d7;">(</span>alpha<span style="color: #4f97d7;">/</span>M<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> gradient<span style="color: #4f97d7;">';</span>  <span style="color: #2aa1ae; background-color: #292e34;">% Nx1</span>
</pre>
</div>

<p>
\[ \theta_{n \times 1}[i+1] = \theta_{n \times 1}[i] - \frac{\alpha}{m} \left[ 1_{1 \times m} \left( X_{m \times n} \theta_{n \times 1} - Y_{m \times 1} \right)_{m \times 1} 1_{1 \times n} X_{m \times n} \right]^T  \]
</p>

<p>
La original es más compacta:
</p>

<p>
\[ \theta_{n \times 1}[i+1] = \theta_{n \times 1}[i] - \frac{\alpha}{m} X_{m \times n}^T (X_{m \times n} \theta_{n \times 1} - Y_{m \times 1} )_{m \times 1} \]
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org6744620" class="outline-2">
<h2 id="org6744620"><span class="section-number-2">5</span> Semana 3</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orge5bbc1e" class="outline-3">
<h3 id="orge5bbc1e"><span class="section-number-3">5.1</span> Classification and representation</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-orge8f3cff" class="outline-4">
<h4 id="orge8f3cff"><span class="section-number-4">5.1.1</span> Classification</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
Vamos a ver la <b>regresión logística</b> que es un algoritmo de clasificación (aunque su nombre diga <i>regresión</i>).
</p>

<p>
La regresión lineal no es un buen método para la clasificación en variables discretas. Acá necesitamos algo más no lineal. Una opción es usar regresión lineal + un umbral arbitrario de separación, pero aún no es suficiente.
</p>

<p>
Vamos a ver clasificación binaria. Definimos como \(0\) y \(1\) a las clases. También usamos <b>etiqueta</b> para denominar a la salida \(h_\theta(x)\).
</p>
</div>
</div>

<div id="outline-container-org47c5dbf" class="outline-4">
<h4 id="org47c5dbf"><span class="section-number-4">5.1.2</span> Hypothesis representation</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
En clasificación binaria, los resultados observados sólo pueden tomar los valores \(0\) y \(1\), y por tanto nuestra función de hipótesis debería también sólo tomar esos valores.
</p>

<p>
Para empezar elegimos una función que esté acotada a ese rango. Una opción es la <b>función logística</b> o <b>sigmoidea</b>:
</p>

<p>
\[ h(z) = \frac{1}{1+e^z} \]
</p>

<p>
\[ h(\theta,x) = h_\theta(x) = \frac{1}{1+e^{\theta^T  x}}\]
</p>

<ul class="org-ul">
<li>Mapea los reales al intervalo \([0, 1]\).</li>
</ul>

<p>
Podemos interpretar los resultados como la probabilidad de que la hipótesis tome un valor, dada determinada entrada.
</p>

<ul class="org-ul">
<li>La suma de las probabilidades debe ser \(1\).</li>
</ul>
</div>


<ol class="org-ol">
<li><a id="orgbb8f10b"></a>La función logística o sigmoidea<br />
<div class="outline-text-5" id="text-5-1-2-1">
<ul class="org-ul">
<li>Se parece a la función cumulativa o función de distribución acumulada de una distribución normal/gaussiana.
<ul class="org-ul">
<li>Pero esta tiene una función explícita, mientras que la FDA de la gaussiana no tiene forma cerrada.</li>
<li>La función de densidad de probabilidad asociada "Se parece a la distribución normal en su forma, pero tiene colas más pesadas (y, por lo tanto, menor curtosis)". <a href="https://es.wikipedia.org/wiki/Distribuci%C3%B3n_log%C3%ADstica">Wikipedia: Distribución logística</a></li>
</ul></li>
<li>Puedo pensar que la FDP de la distribución logística me indica la cantidad de información que me da el valor de un descriptor. En el pico es donde más aporta; luego mientras más me alejo del centro, más claro es que es de una clase o de la otra.</li>
<li>Es una aproximación suave de la función escalón.</li>
</ul>


<div class="figure">
<p><img src="imgs/002-320px-Logistic-curve.svg.png" alt="002-320px-Logistic-curve.svg.png" />
</p>
</div>

<p>
\[ f(x) = \frac{L}{1+e^{-k(x-x_0)}}  \]
</p>

<ul class="org-ul">
<li>\(L\) es el valor máximo.</li>
<li>\(k\) es la tasa de crecimiento o pendiente de la curva.</li>
<li>\(x_0\) es el centro</li>
</ul>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgb5319c1" class="outline-4">
<h4 id="orgb5319c1"><span class="section-number-4">5.1.3</span> Decision boundary</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
La clasificación es discreta; para hacerla discreta necesitamos agregar un umbral a nuestra función de hipótesis. <i>No entiendo por qué pone el umbral como si fuese una cosa aparte de la función de hipótesis</i>. Entonces, para la regresión logística hacemos:
</p>

<p>
\[ y = 0 \quad \text{si} \quad h(z) = h(z(\theta, x)) = h(\theta^T x) \lt 0,5 \]
\[ y = 0 \quad \text{si} \quad h(z) = h(z(\theta, x)) = h(\theta^T x) \geq 0,5 \]
</p>

<p>
Lo que equivale a
</p>

<p>
\[ y = 0 \quad \text{si} \quad  \theta^T x < 0,5 \]
\[ y = 1 \quad \text{si} \quad \theta^T x \ge 0,5 \]
</p>

<p>
La función de entrada a la sigmoidea, \(z(\theta,x)\) define el umbral de decisión. Al igual que vimos para regresión lineal, esta función no tiene por qué ser lineal con respecto a los descriptores (<i>¿mas sí lineal respecto a los parámetros?</i>), y es la que va a separar las clases en su espacio. Por ejemplo, para dos variables podría ser un elipsoide: \( z(\theta,x) = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \theta_3 x_1^2 + \theta_4 x_2^2 \).
</p>
</div>
</div>
</div>

<div id="outline-container-org73a8e37" class="outline-3">
<h3 id="org73a8e37"><span class="section-number-3">5.2</span> Logistic regression model</h3>
<div class="outline-text-3" id="text-5-2">
</div>
<div id="outline-container-org5319bdf" class="outline-4">
<h4 id="org5319bdf"><span class="section-number-4">5.2.1</span> Cost function</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
Sea la función de costo \(J\) la media de una función de error:
</p>

<p>
\[ J(\theta) = \frac{1}{m} \sum_1^m  error(\hat{y}, y) \]
</p>

<p>
Si usamos el error cuadrático medio como función de error para optimizar con el descenso por el gradiente, vamos a tener que derivar una función no lineal. Esto es porque la función logística/sigmoidea \(h(z)\) no es lineal con respecto a los parámetros &theta;, y por tanto el error cuadrático medio no es una función convexa; esto implica que tiene (¿o puede tener?) más de un mínimo.
</p>

<p>
Lo que hacemos entonces es proponer otra función de error que sea convexa y diferenciable. Por supuesto, tiene que penalizar las predicciones/hipótesis erróneas. La que se propone es
</p>

<p>
\[ error(h_\theta(x)) = error(h(\theta,x) = \quad -\log(h_\theta(x)) \quad \text{si} \quad y = 1   \]
\[ error(h_\theta(x)) = error(h(\theta,x) = \quad -\log(1-h_\theta(x)) \quad \text{si} \quad y = 0   \]
</p>


<div class="figure">
<p><img src="./imgs/003-01-logcost1.png" alt="003-01-logcost1.png" />
</p>
</div>




<div class="figure">
<p><img src="./imgs/003-02-logcost2.png" alt="003-02-logcost2.png" />
</p>
</div>

<ul class="org-ul">
<li>Nótese que tienden a infinito en \(0\) y \(1\) respectivamente.</li>
<li>Usamos el <b>logaritmo natural</b>, base \(e\).</li>
</ul>

<hr />

<p>
En la sección siguiente Andrew dice que esta función de costo (en realidad su forma simplificada) se puede derivar estadísticamente a partir del principio de estimación de máxima verisimilitud.
</p>
</div>
</div>

<div id="outline-container-orgc14bd2a" class="outline-4">
<h4 id="orgc14bd2a"><span class="section-number-4">5.2.2</span> Simplified cost function and gradient descent</h4>
<div class="outline-text-4" id="text-5-2-2">
</div>
<ol class="org-ol">
<li><a id="orga0e929e"></a>Forma simplificada<br />
<div class="outline-text-5" id="text-5-2-2-1">
<p>
Teníamos a la función de error para la regresión logística como:
</p>

<p>
\[ error(h_\theta(x)) = error(h(\theta,x)) = \quad -\log(h_\theta(x)) \quad \text{si} \quad y = 1   \]
\[ error(h_\theta(x)) = error(h(\theta,x)) = \quad -\log(1-h_\theta(x)) \quad \text{si} \quad y = 0   \]
</p>

<p>
La forma simplificada es:
</p>

<p>
\[ error(h(\theta,x)) = y (-\log(h_\theta(x))) + (1-y) (-\log(1-h_\theta(x)))   \]
</p>

<p>
\[ error(h(\theta,x)) = -y \log(\hat{y}) - (1-y) \log(\hat{y})  \]
</p>

<p>
Esta función es convexa (si \(h\) es la sigmoidea, al menos).
</p>

<p>
Luego la función de costo queda:
</p>

<p>
\[  J(h_\theta(x)) = J(h(\theta,x)) =  \frac{1}{m} \sum_{i=1}^m \left[ -y^{(i)} \log(h_\theta(x^{(i)})) - (1-y^{(i)}) \log(1-h_\theta(x^{(i)}))  \right]  \]
</p>

<p>
La forma vectorizada/matricial es:
</p>

<p>
\[ J(h(\theta,X)) = \frac{1}{m} \left[ - Y^T \log(h(X\theta)) - (1-Y)^T \log(1-h(X\theta)) \right]  \]
</p>
</div>
</li>

<li><a id="org3a40b24"></a>Descenso por el gradiente<br />
<div class="outline-text-5" id="text-5-2-2-2">
<p>
Resulta que la derivada \(\delta J(\theta,x)/\delta \theta\), es la misma que la que obtuvimos usando el error cuadrático medio (<i>MSE</i>) como función de costo para regresión lineal, y entonces la formula de actualización de parámetros es la misma:
</p>

<p>
\[ \theta_j[n+1] := {\theta}_j[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)}  \]
</p>

<p>
En forma vectorizada/matricial:
</p>

<p>
\[ \theta_{}[i+1] = \theta[i] - \frac{\alpha}{m} X^T (h(X \theta) - Y) \]
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org69acf6e" class="outline-4">
<h4 id="org69acf6e"><span class="section-number-4">5.2.3</span> Advanced optimization</h4>
<div class="outline-text-4" id="text-5-2-3">
<p>
Hay algoritmos generales de optimización mejores (pero más complejos) que el descenso por el gradiente. Andrew nombra:
</p>
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">Gradientes conjugados</a></li>
<li>BFGS (<a href="https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm"><i>Broyden–Fletcher–Goldfarb–Shanno algorithm</i></a>)</li>
<li>L-BFGS (<a href="https://en.wikipedia.org/wiki/Limited-memory_BFGS"><i>Limited memory BFGS</i></a>)</li>
</ul>

<p>
En Octave tenemos la función <code>fminunc</code> (de <i>function minimize unconstrained</i>) que nos permite optimizar usando una función de costo arbitraria. Le tenemos que proveer esa función de costo, que calcula la función de costo y el gradiente en cada iteración. En el ejemplo de Andrew, la función de costo calcula el gradiente de forma analítica, pero asumo que podrías también tener una memoria y usar diferencias.
</p>
</div>
</div>
</div>

<div id="outline-container-org379ef8b" class="outline-3">
<h3 id="org379ef8b"><span class="section-number-3">5.3</span> Multiclass classification</h3>
<div class="outline-text-3" id="text-5-3">
</div>
<div id="outline-container-org386d0cf" class="outline-4">
<h4 id="org386d0cf"><span class="section-number-4">5.3.1</span> Multiclass classification: one vs all</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Si tenemos \(n\) salidas discretas posibles, podemos modelar el problema con \(n\) clasificadores binarios, que toman una salida como caso positivo y el resto como negativo.
</p>

<p>
Una vez que clasificamos con todos los clasificadores, elegimos la salida definitiva como aquella que haya tenido la mayor confianza; y entonces tenemos que ver la probabilidad predicha antes de discretizarla.
</p>

<p>
Nótese que esto también se cumple en los binarios cuando \(n=2\): podemos verlo como que ambos clasificadores definen la misma frontera de decisión.
</p>
</div>
</div>
</div>

<div id="outline-container-org119a85e" class="outline-3">
<h3 id="org119a85e"><span class="section-number-3">5.4</span> Solving the problem of overfitting</h3>
<div class="outline-text-3" id="text-5-4">
</div>
<div id="outline-container-orga9df6f5" class="outline-4">
<h4 id="orga9df6f5"><span class="section-number-4">5.4.1</span> The problem of overfitting</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
Empezamos a evaluar la bondad de ajuste de nuestros modelos.
</p>

<ul class="org-ul">
<li>Un modelo subajustado (<i>underfitted</i>) o de alto sesgo (<i>high bias</i>) tiene mucho error para los datos con los que se entrenó, y por ende muy probablemente tenga mucho error con entradas nuevas. El modelo no captura las características del espacio del problema.
<ul class="org-ul">
<li>El sesgo se asocia con prejuicio. El modelo prejuzga incorrectamente cómo deberían ser las entradas.</li>
</ul></li>
<li>Un modelo sobreajustado (<i>overfitted</i>) predice <i>demasiado</i> correctamente los datos con los que se ajustó, pero no predice correctamente entradas que sean un poco distintas; <b>no generaliza</b>. También se habla de que es un modelo con alta varianza (<i>high variance</i>), porque el espacio de funciones de hipótesis (de la complejidad propuesta) que predicen bien es muy grande; hay muchos grados de libertad.</li>
</ul>

<p>
En los ejemplos mostrados, el ajuste se incrementa con el grado de las funciones de hipótesis, para regresión lineal. Entonces complejizar las funciones de hipótesis implica agregar más descriptores &#x2014;reales o sintéticos&#x2014;.
</p>
</div>

<ol class="org-ol">
<li><a id="org136d95c"></a>Opciones para reducir el sobreajuste<br />
<div class="outline-text-5" id="text-5-4-1-1">
<p>
Las principales formas de reducir el sobreajuste:
</p>

<ol class="org-ol">
<li>Reducir la cantidad de descriptores.
<ul class="org-ul">
<li>Manualmente o con métodos automáticos de selección de modelo.</li>
<li>Perdemos información codificada en los descriptores que eliminamos.</li>
</ul></li>
<li>Usar <b>regularización</b>.
<ul class="org-ul">
<li>Mantenemos todos los descriptores pero los ponderamos.</li>
</ul></li>
</ol>
</div>
</li>
</ol>
</div>

<div id="outline-container-org44c2e55" class="outline-4">
<h4 id="org44c2e55"><span class="section-number-4">5.4.2</span> Cost function</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
Introducimos un parámetro de regularización \(\lambda\) en la función de costo, que pondera la suma de los cuadrados de los parámetros \(\theta\).
</p>

<ul class="org-ul">
<li><i>Creo que este tipo de regularización tiene un nombre</i>.</li>
<li><i>Usamos el cuadrado para que no se cancelen entre sí y porque es derivable supongo</i>.</li>
</ul>

<p>
Por ejemplo, para <i>MSE</i>:
</p>

<p>
\[ J(\theta,x,h(x),\lambda) =  \frac{1}{2m} \left( \sum_{i=1}^{m} \left[ h(\theta,x^{(i)}) - y^{(i)} \right]^2 + \lambda \sum_{j=1}^{n} \theta_j^2 \right)  \]
</p>

<ul class="org-ul">
<li>Se suele omitir la ordenada al origen, término de sesgo o <b>intercepto</b> \(\theta_0\) porque no afecta mucho a los resultados.
<ul class="org-ul">
<li><i>Me parece que debe haber una razón más interesante, porque esta decisión hace que tengamos que calcular las funciones de costo de forma separada para \(\theta_0\)</i>.
<ul class="org-ul">
<li>En verdad es incorrecto pretender que el intercepto sea pequeño. Ver abajo en <a href="#org387261a">5.4.2.0.0.1</a>.</li>
</ul></li>
</ul></li>
</ul>


<p>
Lo que buscamos es tener parámetros pequeños, lo que hace que la función de hipótesis sea suave, simple.
</p>

<p>
Más adelante vamos a ver formas de determinar el valor del parámetro de regularización \(\lambda\) para que funcione. Si es muy grande, hay subajuste, y si es muy chico seguimos con sobreajuste.
</p>
</div>

<ol class="org-ol">
<li><a id="org387261a"></a><span class="done DONE">DONE</span> Buscar por qué no usamos \(\theta_0\)<br />
<div class="outline-text-7" id="text-5-4-2-0-0-1">
<p>
El intercepto es nuestro factor de prejuicio que es independente de los descriptores. Es nuestra respuesta por defecto cuando no tenemos información, y no tiene por qué ser un valor chico. Por tanto no lo introducimos en el algoritmo de regularización.
</p>

<p>
Recordemos que el intercepto es una variable independiente, la ordenada al origen. Lo introducimos dentro del vector de parámetros solo por conveniencia, para simplificar los cálculos.
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org15c979c" class="outline-4">
<h4 id="org15c979c"><span class="section-number-4">5.4.3</span> Regularized linear regression</h4>
<div class="outline-text-4" id="text-5-4-3">
<p>
La función de costo usando error cuadrático medio y regresión lineal nos queda
</p>

<p>
\[ J(\theta,x,h(x),\lambda) =  \frac{1}{2m} \left( \sum_{i=1}^{m} \left[ h(\theta,x^{(i)}) - y^{(i)} \right]^2 + \lambda \sum_{j=1}^{n} \theta_j^2 \right)  \]
</p>

<p>
Nótese que \(j\) empieza en \(1\). La regla de actualización derivada es:
</p>

<p>
\[ \theta_j[n+1] := {\theta}_j[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)} \quad \text{si} \quad j=0 \]
</p>

<p>
\[ \theta_j[n+1] := {\theta}_j[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)} + \frac{\lambda}{m} \theta_j \quad \text{si} \quad j>0 \]
</p>

<p>
Factorizando \(\theta_j\) de esta última ecuación nos queda
</p>

<p>
\[ \theta_j[n+1] := {\theta}_j[n](1 - \frac{\alpha\lambda}{m}) - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)}  \quad \text{si} \quad j>0 \]
</p>

<p>
El factor \((1 - \frac{\alpha\lambda}{m})\) nos indica que en todas las actualizaciones se comienza reduciendo el valor anterior de los parámetros.
</p>
</div>

<ol class="org-ol">
<li><a id="org3f2585d"></a>Forma matricial/vectorizada<br />
<div class="outline-text-5" id="text-5-4-3-1">
<p>
La forma matricial/vectorizada queda
</p>

<p>
\[ J(\theta, X, \lambda) = \frac{1}{2m} \sum (X\theta - Y)^2 + \frac{\lambda}{2m} \theta(1:n)^T \theta(1:n) \]
</p>


<p>
La actualización necesita 2 etapas: la primera es el cálculo normal sin regularización, y de aquí guardamos \(\theta_0\); en la segunda sumamos el termino de regularización; y finalmente reemplazamos con el \(\theta_0\) encontrado anteriormente.
</p>

<p>
\[ \theta[i+1]^{(a)} := \theta[i] - \frac{\alpha}{m} X^T (h(X \theta) - Y) \]
\[ \theta_0[i+1]^{} := \theta[i+1]^{(a)}(0) \]
\[ \theta[i+1]^{} := \theta[i+1]^{(a)} + \frac{\lambda}{2m} \theta[i] \]
\[ \theta[i+1](0) := \theta_0[i+1]  \]
</p>


<hr />
</div>
</li>

<li><a id="org2d12836"></a>La ecuación normal con regularización<br />
<div class="outline-text-5" id="text-5-4-3-2">
<p>
La ecuación normal era
</p>

<p>
\[  \theta = [ ( X^T \times X)^{-1} \times X^T ] \times Y  \]
</p>

<p>
Agregamos un término de regularización:
</p>

<p>
\[  \theta = [ ( X^T \times X \times \lambda L)^{-1} \times X^T ] \times Y  \]
</p>

<p>
Donde L es una matriz diagonal cuyo primer elemento de la diagonal principal es \(0\) e indica que no queremos que la regularización afecte al parámetro &theta;<sub>0</sub> .
</p>

<p>
Este termino de regularización <b>hace que esa matriz sea invertible aunque se trate de un sistema subdeterminado</b> (siempre que \(\lambda>0\)).
</p>
<ul class="org-ul">
<li>En las <a href="https://www.coursera.org/learn/machine-learning/discussions/weeks/3/threads/poUNvD1-EeakuhJbRt69hQ">preguntas frecuentes de la semana 3</a> dicen que <a href="http://web.mit.edu/zoya/www/linearRegression.pdf">acá hay un "boceto de demonstración"</a>.</li>
</ul>
</div>
</li>
</ol>
</div>

<div id="outline-container-org983225c" class="outline-4">
<h4 id="org983225c"><span class="section-number-4">5.4.4</span> Regularized logistic regression</h4>
<div class="outline-text-4" id="text-5-4-4">
<p>
La función de costo de la regresión logística con regularización queda:
</p>

<p>
\[  J(h_\theta(x), \lambda) = J(h(\theta,x)) = \frac{1}{m} \sum_{i=1}^m \left[-y^{(i)} \log(h_\theta(x^{(i)})) - (1-y^{(i)}) \log(1-h_\theta(x^{(i)}))  \right] + \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2 \]
</p>

<p>
La forma vectorizada/matricial:
</p>

<p>
\[ J(h(\theta,X), \lambda) = \frac{1}{m} \left[ -Y^T \log(h(X\theta)) - (1-Y)^T \log(1-h(X\theta)) \right] + \frac{\lambda}{2m} \theta(1:n)^T \theta(1:n) \]
</p>

<p>
La regla de actualización es igual que para regresión lineal con <i>MSE</i>, calculando por separado \(\theta_0\).
</p>
</div>
</div>
</div>





<div id="outline-container-org0d023d8" class="outline-3">
<h3 id="org0d023d8"><span class="section-number-3">5.5</span> Review</h3>
<div class="outline-text-3" id="text-5-5">
</div>
<div id="outline-container-org87e1283" class="outline-4">
<h4 id="org87e1283"><span class="section-number-4">5.5.1</span> Quiz: Regularization</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li>Agregar nuevos descriptores nos da una hipótesis igual o mejor a la que tenemos antes de agregarlos, en los datos de entrenamiento/modelado.
<ul class="org-ul">
<li>Asumo que asume convergencia.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org4bc9297" class="outline-4">
<h4 id="org4bc9297"><span class="section-number-4">5.5.2</span> Programming assignment: logistic regression</h4>
<div class="outline-text-4" id="text-5-5-2">
<ul class="org-ul">
<li>Corregí algunas funciones vectorizadas de mis notas.</li>
<li>El logaritmo es logaritmo natural, no base 10. Por tanto debería escribir \(ln\) en lugar de \(log\), aunque en Octave la función es <code>log</code>.</li>
<li><i>Cross entropy</i></li>
<li>Usamos <i>feature mapping</i> para crear nuevos descriptores a partir de los 2 que teníamos. Los nuevos son todas las combinaciones lineales posibles de descriptores, hasta cierto grado.</li>
</ul>

<div class="org-src-container">
<pre class="src src-octave"><span style="color: #4f97d7; font-weight: bold;">function</span> out <span style="color: #4f97d7;">=</span> <span style="color: #bc6ec5; font-weight: bold;">mapFeature</span><span style="color: #4f97d7;">(</span>X1<span style="color: #4f97d7;">,</span> X2<span style="color: #4f97d7;">)</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">MAPFEATURE Feature mapping function to polynomial features</span>
<span style="color: #2aa1ae; background-color: #292e34;">%</span>
<span style="color: #2aa1ae; background-color: #292e34;">%   </span><span style="color: #2aa1ae; background-color: #292e34;">MAPFEATURE(X1, X2) maps the two input features</span>
<span style="color: #2aa1ae; background-color: #292e34;">%   </span><span style="color: #2aa1ae; background-color: #292e34;">to quadratic features used in the regularization exercise.</span>
<span style="color: #2aa1ae; background-color: #292e34;">%</span>
<span style="color: #2aa1ae; background-color: #292e34;">%   </span><span style="color: #2aa1ae; background-color: #292e34;">Returns a new feature array with more features, comprising of </span>
<span style="color: #2aa1ae; background-color: #292e34;">%   </span><span style="color: #2aa1ae; background-color: #292e34;">X1, X2, X1.^2, X2.^2, X1*X2, X1*X2.^2, etc..</span>
<span style="color: #2aa1ae; background-color: #292e34;">%</span>
<span style="color: #2aa1ae; background-color: #292e34;">%   </span><span style="color: #2aa1ae; background-color: #292e34;">Inputs X1, X2 must be the same size</span>
<span style="color: #2aa1ae; background-color: #292e34;">%</span>

  degree <span style="color: #4f97d7;">=</span> <span style="color: #a45bad;">6</span><span style="color: #4f97d7;">;</span>
  out <span style="color: #4f97d7;">=</span> ones<span style="color: #4f97d7;">(</span>size<span style="color: #bc6ec5;">(</span>X1<span style="color: #2d9574;">(</span><span style="color: #4f97d7;">:,</span><span style="color: #a45bad;">1</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>
  <span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7;">=</span> <span style="color: #a45bad;">1</span><span style="color: #4f97d7;">:</span>degree
    <span style="color: #4f97d7; font-weight: bold;">for</span> j <span style="color: #4f97d7;">=</span> <span style="color: #a45bad;">0</span><span style="color: #4f97d7;">:</span>i
      out<span style="color: #4f97d7;">(</span><span style="color: #4f97d7;">:,</span> end<span style="color: #4f97d7;">+</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">=</span> <span style="color: #4f97d7;">(</span>X1<span style="color: #4f97d7;">.^</span><span style="color: #bc6ec5;">(</span>i<span style="color: #4f97d7;">-</span>j<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">.*</span><span style="color: #4f97d7;">(</span>X2<span style="color: #4f97d7;">.^</span>j<span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>
    <span style="color: #4f97d7; font-weight: bold;">end</span>
  <span style="color: #4f97d7; font-weight: bold;">end</span>

<span style="color: #4f97d7; font-weight: bold;">end</span>

<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">---------</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">Add Polynomial Features</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">Note that mapFeature also adds a column of ones for us, so the intercept</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">term is handled</span>
X <span style="color: #4f97d7;">=</span> mapFeature<span style="color: #4f97d7;">(</span>X<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7;">:,</span><span style="color: #a45bad;">1</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">,</span> X<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7;">:,</span><span style="color: #a45bad;">2</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>

</pre>
</div>

<ul class="org-ul">
<li>\(\theta_0\): manejé los distintos gradientes así:</li>
</ul>

<div class="org-src-container">
<pre class="src src-octave">grad <span style="color: #4f97d7;">=</span> <span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">/</span>m<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> X<span style="color: #4f97d7;">'*</span><span style="color: #4f97d7;">(</span>sigmoid<span style="color: #bc6ec5;">(</span>X<span style="color: #4f97d7;">*</span>theta<span style="color: #bc6ec5;">)</span> <span style="color: #4f97d7;">-</span> y<span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>
grad0 <span style="color: #4f97d7;">=</span> grad<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>
grad <span style="color: #4f97d7;">=</span> grad <span style="color: #4f97d7;">+</span> <span style="color: #4f97d7;">(</span>lambda<span style="color: #4f97d7;">/</span>m<span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">.*</span>theta<span style="color: #4f97d7;">;</span>
grad<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">=</span> grad0<span style="color: #4f97d7;">;</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf624875" class="outline-2">
<h2 id="orgf624875"><span class="section-number-2">6</span> Semana 4</h2>
<div class="outline-text-2" id="text-6">
<p>
Empezamos a ver redes neuronales.
</p>
</div>

<div id="outline-container-org5cf4a99" class="outline-3">
<h3 id="org5cf4a99"><span class="section-number-3">6.1</span> Motivations</h3>
<div class="outline-text-3" id="text-6-1">
</div>
<div id="outline-container-org5f0b313" class="outline-4">
<h4 id="org5f0b313"><span class="section-number-4">6.1.1</span> Non-linear hypotheses</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
Las redes neuronales son de los clasificadores más avanzados y usados hoy en día.
</p>

<p>
Para problemas poco lineales, la regresión logística empieza a necesitar muchos descriptores. Demasiados. Sea por ejemplo un problema con dos descriptores \(x_1\) y \(x_2\). Si queremos más expresividad de clasificación y añadimos como descriptores sintéticos todos los productos de segundo orden, tenemos \(x_1^2 , x_2^2, x_1 x_2\), y tendríamos un total de 5 descriptores. Este total crece como \(O(\frac{n^2}{2})\). Los de tercer orden crecen como \(O(n^3)\).
</p>

<p>
Hay muchos problemas que de entrada ya están definidos por muchos descriptores. Un ejemplo: las imágenes digitales. Por ejemplo, una imagen de 100&times;100px requeriría aproximadamente 50 millones de descriptores de segundo grado.
</p>
</div>
</div>


<div id="outline-container-orgecd3e2e" class="outline-4">
<h4 id="orgecd3e2e"><span class="section-number-4">6.1.2</span> Neurons and the brain</h4>
<div class="outline-text-4" id="text-6-1-2">
<ul class="org-ul">
<li><i>The "one learning algorithm" hypotesis</i>: el cerebro tiene el mismo algoritmo de aprendizaje siempre, y se adapta a cualquier entrada.</li>
</ul>
</div>

<ol class="org-ol">
<li><a id="org8ce6f48"></a><span class="todo TODO">TODO</span> <a href="https://www.lesswrong.com/posts/9Yc7Pp7szcjPgPsjf/the-brain-as-a-universal-learning-machine">https://www.lesswrong.com/posts/9Yc7Pp7szcjPgPsjf/the-brain-as-a-universal-learning-machine</a><br /></li>

<li><a id="org388b37b"></a><span class="todo TODO">TODO</span> <a href="https://www.youtube.com/watch?v=AY4ajbu_G3k">https://www.youtube.com/watch?v=AY4ajbu_G3k</a><br /></li>

<li><a id="org431824e"></a><span class="todo TODO">TODO</span> <a href="https://www.youtube.com/watch?v=NKpuX_yzdYs">https://www.youtube.com/watch?v=NKpuX_yzdYs</a><br /></li>

<li><a id="org6bb10f6"></a><span class="todo TODO">TODO</span> <a href="https://www.youtube.com/watch?v=zIwLWfaAg-8">https://www.youtube.com/watch?v=zIwLWfaAg-8</a><br /></li>

<li><a id="org54e108e"></a><span class="todo TODO">TODO</span> <a href="https://www.wired.com/2013/05/neuro-artificial-intelligence/">https://www.wired.com/2013/05/neuro-artificial-intelligence/</a><br /></li>
</ol>
</div>
</div>

<div id="outline-container-org41c5e56" class="outline-3">
<h3 id="org41c5e56"><span class="section-number-3">6.2</span> Neural networks</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-org96840d0" class="outline-4">
<h4 id="org96840d0"><span class="section-number-4">6.2.1</span> Model representation I</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
Está largo de escribir así que copio la imagen:
</p>


<div class="figure">
<p><img src="./imgs/004-neural-network-model.png" alt="004-neural-network-model.png" />
</p>
</div>

<p>
Algo de nomenclatura y convenciones:
</p>

<ul class="org-ul">
<li>Es equivalente hablar de una <b>unidad</b>, una <b>neurona</b>, la salida de una neurona o la <b>activación</b> de una neurona. Siempre hablamos del resultado de la función de activación ante ciertas entradas y parámetros o pesos: \(g(\theta,x)\). La neurona en sí no tiene significado en el modelo, aunque lo tiene en el diagrama.
<ul class="org-ul">
<li>La unidad 1 de la capa 2 es \(a_1^{(2)}\).</li>
<li>Se suele omitir la unidad de sesgo de cada capa, \(a_0^{(j)}\), porque vale siempre 1. Esta es la que se multiplica por \(\theta_0\). <i>DISCREPO</i>.</li>
</ul></li>
<li>\(h_{\Theta}^{}(\vec{x}^{})\) es la salida final de la red neuronal, en función de las entradas.</li>
<li>La función de activación típica es la función logística/sigmoidea.</li>
<li>A los parámetros de la función también les decimos <b>pesos</b>.
<ul class="org-ul">
<li>&Theta;<sup>(j)</sup> es la matriz de pesos que relaciona la capa \(j\) con la siguiente \(j+1\). Si una capa \(j\) tiene \(s_j\) unidades y la siguiente es \(j+1\) con \(s_{j+1}\) unidades, la dimensión de \(\Theta^{(j)}\) será \((s_{j+1})\times(s_j+1)\) (entradas &times; (salidas + entradas independientes)); el \(+1\) es por la unidad de sesgo.</li>
</ul></li>
<li>En los diagramas se funden axones y dendritas de capas conectadas, adyacentes. Entonces los únicos axones son los de la capa de salida.</li>
<li>A las capas que no son de salida o entrada se les suele llamar <b>capas ocultas</b>.</li>
</ul>
</div>
</div>

<div id="outline-container-org0fa4c23" class="outline-4">
<h4 id="org0fa4c23"><span class="section-number-4">6.2.2</span> Model representation II</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
Este modelo básico de red neuronal es un conjunto de funciones logísticas encadenadas. La forma de conectar las neuronas (arquitectura) le va a permitir aprender funciones no lineales complejas.
</p>

<p>
En forma vectorizada y asumiendo la misma función de activación \(g^{(j)}\) para todas las neuronas:
</p>

<p>
\[ h_{\Theta}^{}(\vec{x}^{}) = h(g, \vec{x}, \Theta) \]
\[ \vec{a}^{(j) }= g_{}^{}(\vec{z}^{(j)}) = g(\Theta^{(j-1)} \vec{a}^{(j-1)})  \]
</p>
</div>
</div>
</div>

<div id="outline-container-orgcc4c775" class="outline-3">
<h3 id="orgcc4c775"><span class="section-number-3">6.3</span> Applications</h3>
<div class="outline-text-3" id="text-6-3">
</div>
<div id="outline-container-orge66a7bf" class="outline-4">
<h4 id="orge66a7bf"><span class="section-number-4">6.3.1</span> Examples and intuitions I</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
Con una neurona de 3 entradas puedo calcular las funciones AND y OR.
</p>
</div>
</div>

<div id="outline-container-orga81a871" class="outline-4">
<h4 id="orga81a871"><span class="section-number-4">6.3.2</span> Examples and intuitions II</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
Ejemplo de XNOR.
</p>
</div>
</div>

<div id="outline-container-orgac7ee74" class="outline-4">
<h4 id="orgac7ee74"><span class="section-number-4">6.3.3</span> Multiclass classification</h4>
<div class="outline-text-4" id="text-6-3-3">
<p>
Para clasificación multiclase solo tenemos que tener tantas salidas como clases. Luego, codificamos la salida como un vector "<i>one hot</i>", donde todos los elementos son \(0\) menos el de la salida correcta, que es \(1\).
</p>

<p>
Las salidas de la red \(\vec{\hat{y}} = h_\Theta(\vec{x})\) no son una distribución de probabilidad, no necesariamente suman 1. Son la salida de distintas sigmoideas, y cada una representa la confianza que tiene ese clasificador.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb76efdc" class="outline-3">
<h3 id="orgb76efdc"><span class="section-number-3">6.4</span> Review</h3>
<div class="outline-text-3" id="text-6-4">
</div>
<div id="outline-container-org108ec1a" class="outline-4">
<h4 id="org108ec1a"><span class="section-number-4">6.4.1</span> Quiz: Neural networks: representation</h4>
</div>

<div id="outline-container-org37dcd8a" class="outline-4">
<h4 id="org37dcd8a"><span class="section-number-4">6.4.2</span> Programming assignment: multi-class classificatin and neural networks</h4>
</div>
</div>
</div>

<div id="outline-container-orgb1396d9" class="outline-2">
<h2 id="orgb1396d9"><span class="section-number-2">7</span> Semana 5</h2>
<div class="outline-text-2" id="text-7">
<p>
Vamos a ver el algoritmo de retropropagación o propagación hacia atrás (<i>backpropagation</i>) para el aprendizaje de redes neuronales.
</p>
</div>

<div id="outline-container-org372733c" class="outline-3">
<h3 id="org372733c"><span class="section-number-3">7.1</span> Cost function and backpropagation</h3>
<div class="outline-text-3" id="text-7-1">
</div>
<div id="outline-container-org471a024" class="outline-4">
<h4 id="org471a024"><span class="section-number-4">7.1.1</span> Cost function</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
Para optimizar un conjunto de parámetros \(\Theta\) necesitamos primero definir una función de costo a minimizar.
</p>

<p>
Algunas definiciones:
</p>

<ul class="org-ul">
<li>\(K\) es la cantidad de salidas de la red.
<ul class="org-ul">
<li>Usamos \(k\) para indizarlas.</li>
</ul></li>
<li>\(L\) es la cantidad de capas de nuestra red.
<ul class="org-ul">
<li>Usamos \(l\) para indizarlas.</li>
</ul></li>
<li>\(s_l\) es la cantidad de neuronas/unidades de la capa \(l\), <b>sin contar la unidad de sesgo \(a_0^{(l)}\)</b>.</li>
</ul>

<p>
La función de costo es una extensión de la regularizada que usábamos para regresión logística.
</p>

<ul class="org-ul">
<li>Sumamos los errores de todas las salidas.</li>
<li>Regularizamos todos los parámetros \(\theta\) de las matrices \(\Theta\), excepto aquellos que relacionan unidades de sesgo. Estos son corresponden a <del>la primera fila y</del> la primera columna de cada \(\Theta\).</li>
</ul>

<p>
\[  J(\Theta, \lambda) = \frac{1}{m} \sum_{k=1}^K \sum_{i=1}^m \left[-y_k^{(i)} \log(h_\Theta(x^{(i)})_k) - (1-y_k^{(i)}) \log(1-h_\Theta(x^{(i)})_k)  \right] + \frac{\lambda}{2m} \sum_{l=1}^L \sum_{v=0}^{s_{l+1}} \sum_{j=1}^{s_l} (\Theta_{v,j}^{(l)})^2 \]
</p>

<ul class="org-ul">
<li><i>Yo voy a usar \(v\) donde él usa OTRA \(i\)</i>.</li>
</ul>
</div>
</div>


<div id="outline-container-org5564f08" class="outline-4">
<h4 id="org5564f08"><span class="section-number-4">7.1.2</span> Backpropagation algorithm</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
Esto está complicado así que nos lo dan sin demostraciones.
</p>

<p>
El algoritmo de retropropagación o propagación hacia atrás sirve para calcular el gradiente de la función de costo en función de los parámetros. Luego usamos este gradiente <b>en algún algoritmo de optimización</b> como el descenso por el gradiente, para encontrar los parámetros que minimizan la función de costo.
</p>

<p>
\[  \frac{\partial J(\Theta)}{\partial \Theta_{v,j}^{(l)} } = D_{v,j}^{(l)}  \]
</p>

<p>
\[ D_{v,j}^{(l)} = \frac{1}{m} \Delta_{v,j}^{(l)} + \lambda \Theta_{v,j}^{(l)} \quad \text{si} \quad j=0  \]
</p>

<p>
\[ D_{v,j}^{(l)} = \frac{1}{m} \Delta_{v,j}^{(l)} \quad \text{si} \quad j\ne0  \]
</p>

<p>
\(\Delta_{v,j}^{(l)}\) son matrices en las que vamos acumulando los errores de cada unidad de cada capa, para cada ejemplo de entrada. El proceso es:
</p>

<ol class="org-ol">
<li>Para cada ejemplo \(x{(i)}\):
<ol class="org-ol">
<li>Calculamos las salidas de la red, propagando hacia adelante.</li>
<li>Calculamos los errores, propagando hacia atrás.</li>
</ol></li>
</ol>

<p>
\[  \Delta_{v,j}^{(l)} [n+1] := \Delta_{v,j}^{(l)} [n] + \vec{a}_j^{(l)} \vec{\delta}_{v}^{(l+1)} \]
</p>

<p>
De forma vectorizada/matricial:
</p>

<p>
\[ \Delta^{(l)}[n+1] := \Delta^{(l)}[n] + \delta^{(l+1)} (a^{(l)})^T   \]
</p>


<p>
\(\vec{\delta}^{(l)}\) es un vector de los errores para cada capa. Si no entiendo mal, es la derivada de \(g\) en el punto determinado por sus entradas, multiplicado por el avance del error retropropagado.
</p>

<p>
\[  \vec{\delta}^{(l=L)} :=  \vec{a}^{(l)} - \vec{y}^{}  \]
</p>

<p>
\[  \vec{\delta}^{( 1 \lt l \lt L )} := (\Theta^{(l)})^T \vec{\delta}^{(l+1)} * \vec{g'}(z^{(l)})  \]
</p>

<p>
\[ \vec{g'} (z^{(l)}) = \vec{a}^{(l)} .* (\vec{1} - \vec{a}^{(l)} )  \]
</p>
</div>
</div>





<div id="outline-container-orgbc0a3fa" class="outline-4">
<h4 id="orgbc0a3fa"><span class="section-number-4">7.1.3</span> Backpropagation intuition</h4>
<div class="outline-text-4" id="text-7-1-3">
<p>
Los términos \(\delta\) son los "errores" de predicción de cada unidad. Más técnicamente:
</p>

<p>
\[  \delta_j^{(l)} = \frac{\partial costo(h_\Theta, x^{(i)})}{\partial z_j^{(l)}}   \]
</p>

<p>
Así como cada \(z^{(l)}\) es una suma pesada de las entradas a esa unidad, cada \(\delta^{(l)}\) es una suma pesada de las entradas a esa unidad, recorriendo el grafo al revés, desde las salidas a hacia las entradas.
</p>
</div>
</div>
</div>

<div id="outline-container-orgecf5c3a" class="outline-3">
<h3 id="orgecf5c3a"><span class="section-number-3">7.2</span> Backpropagation in practice</h3>
<div class="outline-text-3" id="text-7-2">
</div>
<div id="outline-container-orgc3e46b7" class="outline-4">
<h4 id="orgc3e46b7"><span class="section-number-4">7.2.1</span> Implementation note: unrolling parameters</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
Muchos algoritmos de optimización esperan vectores. Para trabajar con nuestras matrices \(\Theta\) de parámetros y \(D\) de gradientes, lo que hacemos es juntar todos los elementos y expresarlos como vector. Luego las reconstruimos en donde sea necesario.
</p>

<p>
En Octave:
</p>

<div class="org-src-container">
<pre class="src src-octave">Theta1 <span style="color: #4f97d7;">=</span> rand<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">4</span><span style="color: #4f97d7;">,</span><span style="color: #a45bad;">3</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>  <span style="color: #2aa1ae; background-color: #292e34;">% 4x3</span>
Theta2 <span style="color: #4f97d7;">=</span> rand<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">2</span><span style="color: #4f97d7;">,</span><span style="color: #a45bad;">4</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>  <span style="color: #2aa1ae; background-color: #292e34;">% 2x4</span>
ThetaVec <span style="color: #4f97d7;">=</span> <span style="color: #4f97d7;">[</span>Theta1<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7;">:</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">;</span> Theta2<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7;">:</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">]</span><span style="color: #4f97d7;">;</span>  <span style="color: #2aa1ae; background-color: #292e34;">% 20x1</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">[J, DVec]  = costFunction(ThetaVec, X, Y)  % Adentro reconstruimos ThetaVec</span>
ThetaVecOptimized <span style="color: #4f97d7;">=</span> fminunc<span style="color: #4f97d7;">(</span><span style="color: #4f97d7;">...</span><span style="color: #4f97d7;">)</span>
Theta1 <span style="color: #4f97d7;">=</span> reshape<span style="color: #4f97d7;">(</span>ThetaVecOptimized<span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">:</span><span style="color: #a45bad;">11</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">,</span> <span style="color: #a45bad;">4</span><span style="color: #4f97d7;">,</span><span style="color: #a45bad;">3</span><span style="color: #4f97d7;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfcef775" class="outline-4">
<h4 id="orgfcef775"><span class="section-number-4">7.2.2</span> Gradient checking</h4>
<div class="outline-text-4" id="text-7-2-2">
<p>
Para verificar que nuestro algoritmo de retropropagación esté funcionando bien, podemos comparar los gradientes \(D\) calculados con unos calculados manualmente usando una aproximación de la derivada en el punto. Andrew sugiere usar una aproximación de doble lado:
</p>

<p>
\[  \frac{\partial J(\Theta)}{\partial \Theta}   \approx  \frac{J(\Theta + \epsilon) - J(\Theta - \epsilon)}{2 \epsilon}\]
</p>

<p>
Calculamos esto para cada uno de los parámetros \(\theta\) del vector desenrollado a partir de las matrices \(\Theta\). Calculamos para cada parámetro, manteniendo el resto fijos; es la derivada parcial.
</p>

<p>
<b>¡Nótese que podríamos optimizar con esto!</b> El problema es que es computacionalmente mucho más costoso que el algoritmo de retropropagación. Implica recalcular la función de costo 2 veces para cada parámetro de las matrices. Por lo tanto, solo lo deberíamos usar para depurar nuestro código, pero luego desactivarlo.
</p>
</div>
</div>

<div id="outline-container-org8ce714b" class="outline-4">
<h4 id="org8ce714b"><span class="section-number-4">7.2.3</span> Random initialization</h4>
<div class="outline-text-4" id="text-7-2-3">
<p>
Si inicializamos los parámetros \(\theta\) de las matrices \(\Theta\) todos con el mismo valor, en cada iteración de propagación hacia adelante terminamos con las mismas activaciones en cada unidad de una misma capa; y en cada iteración de propagación hacia atrás terminamos con los mismos errores \(\delta\). Esto implica que todas las unidades de una capa terminan calculando los mismos descriptores. Esto se llama el <b>problema de los caminos simétricos</b>. <i>Supongo que se da porque todas las unidades están conectadas de la misma manera, quizás no sería necesario si las unidades se conectaran de forma distinta</i>.
</p>

<p>
La forma de solucionar el problema es romper la simetría (<i>simmetry breaking</i>). Para esto debemos inicializar los parámetros con valores distintos. Andrew propone inicializarlos con valores aleatorios (distribución uniforme) en un intervalo \([-\epsilon, \epsilon]\) para un valor \(\epsilon\) pequeño cualquiera (propone un \(\epsilon<1\)).
</p>
</div>
</div>

<div id="outline-container-org5f15b42" class="outline-4">
<h4 id="org5f15b42"><span class="section-number-4">7.2.4</span> Putting it together</h4>
<div class="outline-text-4" id="text-7-2-4">
<ul class="org-ul">
<li>La arquitectura es el patrón de conexión entre las neuronas.
<ul class="org-ul">
<li>Lo más básico es tener una capa oculta (pero no dice de cuántas unidades).</li>
<li>Una buena heurística es tener tantas capas ocultas como unidades de entrada.</li>
</ul></li>
<li>Recordamos que el algoritmo de retropropagación es un algoritmo para calcular el gradiente de la función de costo respecto a la variación de los parámetros; la optimización se hace con un algoritmo genérico de optimización, como el descenso por el gradiente.</li>
<li>\(J(\Theta)\) no es un espacio convexo en las redes neuronales. Esto implica que quizás no alcanzamos el mínimo global, pero dice Andrew que esto no suele ser un problema en la realidad.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org23a1c5d" class="outline-3">
<h3 id="org23a1c5d"><span class="section-number-3">7.3</span> Applications of neural networks</h3>
<div class="outline-text-3" id="text-7-3">
</div>
<div id="outline-container-org0ce5617" class="outline-4">
<h4 id="org0ce5617"><span class="section-number-4">7.3.1</span> Autonomous driving</h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
Jeep automanejado en 1992.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb708e12" class="outline-3">
<h3 id="orgb708e12"><span class="section-number-3">7.4</span> Review</h3>
<div class="outline-text-3" id="text-7-4">
</div>
<div id="outline-container-orge454400" class="outline-4">
<h4 id="orge454400"><span class="section-number-4">7.4.1</span> Quiz: Neural networks: learning</h4>
</div>

<div id="outline-container-org7868e21" class="outline-4">
<h4 id="org7868e21"><span class="section-number-4">7.4.2</span> Programming assignment: neural network learning</h4>
<div class="outline-text-4" id="text-7-4-2">
<ul class="org-ul">
<li>Usé una forma vectorizada de la función de costo, según algunas pistas que encontré en las notas del curso. En ellas usé la <i>traza</i> de una matriz, para trabajar con muchas salidas.</li>
</ul>

<div class="org-src-container">
<pre class="src src-octave"><span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">C&#225;lculo de la funci&#243;n de costo</span>
y_onehot <span style="color: #4f97d7;">=</span> zeros<span style="color: #4f97d7;">(</span>num_labels<span style="color: #4f97d7;">,</span> m<span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>  <span style="color: #2aa1ae; background-color: #292e34;">% s3xm</span>
<span style="color: #4f97d7; font-weight: bold;">for</span> i <span style="color: #4f97d7;">=</span> <span style="color: #a45bad;">1</span><span style="color: #4f97d7;">:</span>m  <span style="color: #2aa1ae; background-color: #292e34;">% cada columna</span>
  y_onehot<span style="color: #4f97d7;">(</span>y<span style="color: #bc6ec5;">(</span>i<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">,</span>i<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">=</span> <span style="color: #a45bad;">1</span><span style="color: #4f97d7;">;</span>
<span style="color: #4f97d7; font-weight: bold;">endfor</span>

<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">C&#225;lculo totalmente vectorizado:</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">Uso la traza (suma de la diagonal principal), pero tambi&#233;n podr&#237;a ser la suma de</span>
<span style="color: #2aa1ae; background-color: #292e34;">%  </span><span style="color: #2aa1ae; background-color: #292e34;">todos los elementos del producto elemento a elemento.</span>
J <span style="color: #4f97d7;">=</span> <span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">/</span>m<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> <span style="color: #4f97d7;">(</span>trace<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7;">-</span>y_onehot <span style="color: #4f97d7;">*</span> log<span style="color: #2d9574;">(</span>a3<span style="color: #4f97d7;">'</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span> <span style="color: #4f97d7;">-</span> trace<span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span><span style="color: #a45bad;">1</span>.<span style="color: #4f97d7;">-</span>y_onehot<span style="color: #2d9574;">)</span> <span style="color: #4f97d7;">*</span> log<span style="color: #2d9574;">(</span><span style="color: #a45bad;">1</span>.<span style="color: #4f97d7;">-</span>a3<span style="color: #4f97d7;">'</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span> <span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>

<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">Agrego regularizaci&#243;n</span>
J <span style="color: #4f97d7;">=</span> J <span style="color: #4f97d7;">+</span> <span style="color: #4f97d7;">(</span>lambda<span style="color: #4f97d7;">/</span><span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">2</span><span style="color: #4f97d7;">*</span>m<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> <span style="color: #4f97d7;">(</span>sum<span style="color: #bc6ec5;">(</span>sum<span style="color: #2d9574;">(</span>Theta1<span style="color: #67b11d;">(</span><span style="color: #4f97d7;">:,</span><span style="color: #a45bad;">2</span><span style="color: #4f97d7;">:</span>end<span style="color: #67b11d;">)</span><span style="color: #4f97d7;">.^</span><span style="color: #a45bad;">2</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span> <span style="color: #4f97d7;">+</span>  sum<span style="color: #bc6ec5;">(</span>sum<span style="color: #2d9574;">(</span>Theta2<span style="color: #67b11d;">(</span><span style="color: #4f97d7;">:,</span><span style="color: #a45bad;">2</span><span style="color: #4f97d7;">:</span>end<span style="color: #67b11d;">)</span><span style="color: #4f97d7;">.^</span><span style="color: #a45bad;">2</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>
</pre>
</div>

<p>
Sin regularización:
</p>

<p>
\[ J = \frac{1}{m} \times \left( tr( Y \times -log(\hat{Y}) ) - tr(  (1-Y) \times -log(1-\hat{Y})  ) \right)  \]
</p>

<p>
\[ J = \frac{1}{m} \times \left(  \sum \left[ Y \odot -log(\hat{Y})  \right] - \sum \left[ (1-Y) \odot -log(1 - \hat{Y})  \right] \right)   \]
</p>

<ul class="org-ul">
<li>One hot.</li>
<li>Implementé una forma vectorizada de la retropropagación, basada en lo que encontré <a href="https://medium.com/secure-and-private-ai-math-blogging-competition/https-medium-com-fadymorris-understanding-vectorized-implementation-of-neural-networks-dae4115ca185">acá</a>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-octave"><span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">Retropropagaci&#243;n</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">https://medium.com/secure-and-private-ai-math-blogging-competition/https-medium-com-fadymorris-understanding-vectorized-implementation-of-neural-networks-dae4115ca185</span>
delta3 <span style="color: #4f97d7;">=</span> a3 <span style="color: #4f97d7;">-</span> y_onehot<span style="color: #4f97d7;">;</span>
delta2 <span style="color: #4f97d7;">=</span> <span style="color: #4f97d7;">(</span>Theta2<span style="color: #4f97d7;">'</span> <span style="color: #4f97d7;">*</span> delta3<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">.*</span> sigmoidGradient<span style="color: #4f97d7;">(</span><span style="color: #bc6ec5;">[</span>ones<span style="color: #2d9574;">(</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">,</span>size<span style="color: #67b11d;">(</span>z2<span style="color: #4f97d7;">,</span><span style="color: #a45bad;">2</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #4f97d7;">;</span>z2<span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>
Delta2 <span style="color: #4f97d7;">=</span> delta3 <span style="color: #4f97d7;">*</span> a2<span style="color: #4f97d7;">';</span>
Delta1 <span style="color: #4f97d7;">=</span> delta2<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">2</span><span style="color: #4f97d7;">:</span>end<span style="color: #4f97d7;">,</span> <span style="color: #4f97d7;">:</span><span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> a1<span style="color: #4f97d7;">';</span>
D2 <span style="color: #4f97d7;">=</span> <span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">/</span>m<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> Delta2 <span style="color: #4f97d7;">+</span> <span style="color: #4f97d7;">(</span>lambda<span style="color: #4f97d7;">/</span>m<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> <span style="color: #4f97d7;">[</span>zeros<span style="color: #bc6ec5;">(</span>size<span style="color: #2d9574;">(</span>Theta2<span style="color: #4f97d7;">,</span><span style="color: #a45bad;">1</span><span style="color: #2d9574;">)</span><span style="color: #4f97d7;">,</span><span style="color: #a45bad;">1</span><span style="color: #bc6ec5;">)</span> <span style="color: #4f97d7;">,</span> Theta2<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7;">:,</span><span style="color: #a45bad;">2</span><span style="color: #4f97d7;">:</span>end<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">]</span><span style="color: #4f97d7;">;</span>
D1 <span style="color: #4f97d7;">=</span> <span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">/</span>m<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> Delta1 <span style="color: #4f97d7;">+</span> <span style="color: #4f97d7;">(</span>lambda<span style="color: #4f97d7;">/</span>m<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> <span style="color: #4f97d7;">[</span>zeros<span style="color: #bc6ec5;">(</span>size<span style="color: #2d9574;">(</span>Theta1<span style="color: #4f97d7;">,</span><span style="color: #a45bad;">1</span><span style="color: #2d9574;">)</span><span style="color: #4f97d7;">,</span><span style="color: #a45bad;">1</span><span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">,</span> Theta1<span style="color: #bc6ec5;">(</span><span style="color: #4f97d7;">:,</span><span style="color: #a45bad;">2</span><span style="color: #4f97d7;">:</span>end<span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">]</span><span style="color: #4f97d7;">;</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org946e9fd" class="outline-2">
<h2 id="org946e9fd"><span class="section-number-2">8</span> Semana 6</h2>
<div class="outline-text-2" id="text-8">
<p>
En esta semana vamos a ver cómo evaluar nuestros modelos.
</p>

<ul class="org-ul">
<li>Advice for applying machine learning</li>
<li>Machine learning system design</li>
</ul>

<blockquote>
<p>
To optimize a machine learning algorithm, you’ll need to first understand where the biggest improvements can be made. [&#x2026;]
</p>

<p>
When you're applying machine learning to real problems, a solid grasp of this week's content will easily save you a large amount of work.
</p>
</blockquote>
</div>

<div id="outline-container-org96b0b20" class="outline-3">
<h3 id="org96b0b20"><span class="section-number-3">8.1</span> Evaluating a learning algorithm</h3>
<div class="outline-text-3" id="text-8-1">
</div>
<div id="outline-container-orga0843ad" class="outline-4">
<h4 id="orga0843ad"><span class="section-number-4">8.1.1</span> Deciding what to try next</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
Algunas cosas que podemos cambiar para intentar mejorar nuestros algoritmos si no estamos satisfechos con los resultados:
</p>
<ul class="org-ul">
<li>Obtener más ejemplos</li>
<li>Generar más descriptores / proponer un modelo más complejo.
<ul class="org-ul">
<li>Sintéticos (modelos más complejos, descriptores polinomiales)</li>
<li>Reales</li>
</ul></li>
<li>Usar menos descriptores / proponer un modelo más simple.</li>
<li>Variar el factor de regularización \(\lambda\).</li>
<li>Aumentar las iteraciones buscando la convergencia.</li>
</ul>

<p>
Algunas de esas decisiones pueden ser muy costosas o largas. Vamos a ver herramientas de diagnóstico que nos pueden dar pista sobre qué es mejor probar.
</p>
</div>
</div>

<div id="outline-container-orgf397965" class="outline-4">
<h4 id="orgf397965"><span class="section-number-4">8.1.2</span> Evaluating a hypothesis</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
Dividimos el conjunto de datos en 2 subconjuntos de muestras aleatorias:
</p>

<ol class="org-ol">
<li>Conjunto de entrenamiento. Sobre estos datos optimizamos nuestros parámetros.</li>
<li>Conjunto de evaluación/prueba. Sobre estos datos evaluamos el desempeño de nuestro modelo.</li>
</ol>

<p>
Para evaluar el desempeño Andrew propone:
</p>

<ul class="org-ul">
<li>En regresión:
<ul class="org-ul">
<li>MSE</li>
</ul></li>
<li>En clasificación:
<ul class="org-ul">
<li>La misma función de costo que usamos para optimizar.</li>
<li>Error medio de predicción / error de clasificación 0/1. Es el error usando las salidas <i>one-hot</i>.</li>
</ul></li>
</ul>

<p>
Tanto en la función de costo \(J_{validation}\) como en la \(J_{test}\) <span class="underline">no incluímos los términos de regularización</span>.
</p>
</div>
</div>


<div id="outline-container-orgac4a1ea" class="outline-4">
<h4 id="orgac4a1ea"><span class="section-number-4">8.1.3</span> Model selection and train/validation/test sets</h4>
<div class="outline-text-4" id="text-8-1-3">
<p>
Andrew propone usar usar un tercer subconjunto, intermedio, sobre el cuál podemos evaluar <b>hiperparámetros</b> o parámetros de más alto nivel. Entonces:
</p>

<ol class="org-ol">
<li>Conjunto de entrenamiento
<ul class="org-ul">
<li>60%</li>
<li>Aquí ajustamos los parámetros básicos de nuestro modelo, \(\theta\).</li>
</ul></li>
<li>Conjunto de validación (cruzada)
<ul class="org-ul">
<li>20%</li>
<li>Acá ajustamos parámetros que definen la estructura de nuestro modelo. Por ejemplo, el grado del polinomio de ajuste. O sea que ajustamos los \(\theta\) de modelos con distintos grados \(d\) y elegimos un \(d\) según su desempeño en este conjunto.</li>
</ul></li>
<li>Conjunto de evaluación
<ul class="org-ul">
<li>20%</li>
<li>Acá estimamos el desempeño real de nuestro modelo.</li>
</ul></li>
</ol>
</div>

<ol class="org-ol">
<li><a id="orga512c61"></a>Discusión<br />
<div class="outline-text-5" id="text-8-1-3-1">
<p>
No me queda claro por qué no podríamos ajustar parámetros e hiperparámetros en simultáneo. ¿Y con qué criterio distinguimos los unos de los otros?
</p>

<ul class="org-ul">
<li>Otro hiperparámetro podría ser un umbral de clasificación.</li>
</ul>
</div>
</li>
</ol>
</div>
</div>


<div id="outline-container-orgbee5aeb" class="outline-3">
<h3 id="orgbee5aeb"><span class="section-number-3">8.2</span> Bias vs variance</h3>
<div class="outline-text-3" id="text-8-2">
</div>
<div id="outline-container-org2946627" class="outline-4">
<h4 id="org2946627"><span class="section-number-4">8.2.1</span> Diagnosing bias vs variance</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
Cuando tenemos mucho error en el conjunto de validación, hay una forma de saber si es error de sesgo alto o error de varianza alta:
</p>
<ul class="org-ul">
<li>Si \(J_{train} \approx J_{val}\) y ambos son altos, entonces el modelo tiene sesgo alto y está subajustando.</li>
<li>Si \(J_{val} \gg J_{train}\) (suponiendo que estamos minimizando el error), entonces el modelo tiene varianza alta y está sobreajustando.</li>
</ul>


<div class="figure">
<p><img src="./imgs/005-high-bias-vs-high-variance.png" alt="005-high-bias-vs-high-variance.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-org303d0ae" class="outline-4">
<h4 id="org303d0ae"><span class="section-number-4">8.2.2</span> Regularization and bias/variance</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
El comportamiento de las funciones de costo respecto a \(\lambda\) es espejado al que se observa según el grado del polinomio; esto es, \(J_train\) crece proporcionalmente a \(\lambda\).
</p>

<p>
Andrew propone elegir un conjunto de valores posibles de \(\lambda\) y evaluarlos para cada uno de los posibles valores de \(d\).
</p>

<p>
Algo interesante comentado en <a href="https://www.coursera.org/learn/machine-learning/discussions/weeks/6/threads/P3Cp9j_ZEeaDRA5SxbW7qQ">las preguntas frecuentes de la semana 6</a>, respecto a hacerlo de forma secuencial:
</p>

<blockquote>
<p>
Q5) What does Prof Ng mean when he says we're "fitting another parameter 'd' to the CV set"?
</p>

<p>
We use the CV set to make adjustments to the model. Prof Ng is referring to adjusting both the regularization and the polynomial degree.
</p>

<p>
But there is a problem.
</p>

<p>
Each subset of data can only be used for one purpose. If you have one CV set and use it to adjust the regularization, then you cannot continue using the same CV set to select the best polynomial degree. This would result in overfitting the CV set.
</p>

<p>
One solution is to further split the data set so you have two CV sets, and use one to adjust the regularization, and the second to select the best polynomial degree. But this increases the amount of labeled data that is needed.
</p>

<p>
A second solution is possible. You can create all possible combinations of the parameters 'd' and lambda, and evaluate each combination using only one validation set. You then select the combination that gives the lowest validation set error. Only one CV set is needed.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org88af548" class="outline-4">
<h4 id="org88af548"><span class="section-number-4">8.2.3</span> Learning curves</h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
Las gráficas de aprendizaje muestran la variación de los errores de entrenamiento y validación ante el cambio de cantidad de muestras de entrenamiento, para una complejidad de modelo fija.
</p>

<p>
Cuando nuestro modelo sufre de alto sesgo, vemos que \(J_{train}\) y \(J_{CV}\) pronto se estancan en un valor. El modelo no puede explicar más variación.
</p>


<div class="figure">
<p><img src="./imgs/006-1-learning-curves.png" alt="006-1-learning-curves.png" />
</p>
</div>

<p>
Para un modelo con alta varianza, las curvas varían lentamente y tienden a converger, pero van a necesitar de muchos ejemplos para poder encontrar la generalización.
</p>


<div class="figure">
<p><img src="./imgs/006-2-learning-curves.png" alt="006-2-learning-curves.png" />
</p>
</div>

<p>
Estaría bueno tener una gráfica de como varían esas curvas al cambiar la complejidad del modelo&#x2026;
</p>
</div>
</div>

<div id="outline-container-orgb78ab84" class="outline-4">
<h4 id="orgb78ab84"><span class="section-number-4">8.2.4</span> Deciding what to do next revisited</h4>
<div class="outline-text-4" id="text-8-2-4">
<hr />

<p>
La regularización sirve para forzar la exploración de todo el espacio de parámetros, y bajo la suposición de que los descriptores están normalizados. La regularización intenta que todos los descriptores afecten en la decisión, y esto puede ser mentira. Me parece que sería mejor atacar el problema con la complejidad del modelo, no con regularización.
</p>
</div>
</div>
</div>

<div id="outline-container-org14c35ff" class="outline-3">
<h3 id="org14c35ff"><span class="section-number-3">8.3</span> Review</h3>
<div class="outline-text-3" id="text-8-3">
</div>
<div id="outline-container-orgb4c63e9" class="outline-4">
<h4 id="orgb4c63e9"><span class="section-number-4">8.3.1</span> Quiz: advice for applying machine learning</h4>
</div>

<div id="outline-container-orgd842564" class="outline-4">
<h4 id="orgd842564"><span class="section-number-4">8.3.2</span> Programming assignment: regularized linear regression and bias/variance</h4>
</div>
</div>

<div id="outline-container-org5fe1c1c" class="outline-3">
<h3 id="org5fe1c1c"><span class="section-number-3">8.4</span> Building a spam classifier</h3>
<div class="outline-text-3" id="text-8-4">
</div>
<div id="outline-container-org2f362f5" class="outline-4">
<h4 id="org2f362f5"><span class="section-number-4">8.4.1</span> Prioritizing what to work on</h4>
</div>

<div id="outline-container-org3d8f13f" class="outline-4">
<h4 id="org3d8f13f"><span class="section-number-4">8.4.2</span> Error analysis</h4>
<div class="outline-text-4" id="text-8-4-2">
<ul class="org-ul">
<li>Hacer una implementación rápida de un clasificador y sus pruebas, para tener información de en qué paso gastar tiempo a continuación. Esto es importante.</li>
<li>Podemos construir curvas de aprendizaje para ver si necesitamos más o menos ejemplos, modelos más complejos, etcétera.</li>
<li>Podemos analizar manualmente los casos mal clasificados (o con mucho error en caso de regresión, supongo), para intentar observar patrones.</li>
<li>Siempre es bueno tener una única métrica de evaluación. Esta nos va a permitir discernir si una estrategia es buena o no.</li>
<li>Es muy recomendable evaluar las cosas en los conjuntos de validación cruzada, no en el conjunto de evaluación. Nunca ajustamos nada en el conjunto de evaluación.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgf3c678c" class="outline-3">
<h3 id="orgf3c678c"><span class="section-number-3">8.5</span> Handling skewed data</h3>
<div class="outline-text-3" id="text-8-5">
</div>
<div id="outline-container-org0eab9f7" class="outline-4">
<h4 id="org0eab9f7"><span class="section-number-4">8.5.1</span> Error metrics for skewed classes</h4>
<div class="outline-text-4" id="text-8-5-1">
<p>
En clasificación (¿binaria?) en la distribución de las clases está muy sesgada (una de las clases es muy rara, tiene poca frecuencia), no es apropiado usar la precisión como métrica. Aquí corresponde analizar la precisión y la exhaustividad (<i>recall</i>).
</p>


<div class="figure">
<p><img src="./imgs/007- precisionrecall.svg.png" alt="007- precisionrecall.svg.png" />
</p>
</div>

<p>
Podemos variar el comportamiento del modelo al modificar el umbral de decisión a la salida (esto es un hiperparámetro, y lo evaluamos en el conjunto de validación).
</p>
</div>
</div>

<div id="outline-container-orgf76bc14" class="outline-4">
<h4 id="orgf76bc14"><span class="section-number-4">8.5.2</span> Trading off precision and recall</h4>
<div class="outline-text-4" id="text-8-5-2">
<p>
Una métrica que incluye la precisión y la exhaustividad es el Valor F (<i>F score</i>), que se define como la media armónica (ponderada) de la precisión y exhaustividad.
</p>

<p>
\[ F_\beta = (1 + \beta^2) \frac{precision \cdot recall}{(\beta^2 \cdot precision) + recall}  \]
</p>

<p>
\(\beta\) es cuántas veces es la exhaustividad más importante que la precisión. Normalmente se usa \(\beta = 1\), obteniendo la métrica \(F_1\) que pondera de igual manera la precisión y la exhaustividad.
</p>

<p>
\[ F_\beta \in [0, 1] \]
</p>
</div>
</div>
</div>


<div id="outline-container-org53e9b73" class="outline-3">
<h3 id="org53e9b73"><span class="section-number-3">8.6</span> Using large datasets</h3>
<div class="outline-text-3" id="text-8-6">
</div>
<div id="outline-container-org0877455" class="outline-4">
<h4 id="org0877455"><span class="section-number-4">8.6.1</span> Data for machine learning</h4>
<div class="outline-text-4" id="text-8-6-1">
<p>
Si tenemos
</p>

<ul class="org-ul">
<li>un conjunto de descriptores suficientemente expresivo como para determinar correctamente la salida a partir de ellos (si un humano experto puede hacerlo a partir de esas entradas, el sistema también podrá);</li>
<li>un modelo complejo, de poco sesgo, que no se va a sobreajustar;</li>
</ul>

<p>
entonces la forma de mejorar los resultados es con más y más datos de entrenamiento.
</p>

<p>
En la publicación <a href="https://www.microsoft.com/en-us/research/publication/mitigating-the-paucity-of-data-problem-exploring-the-effect-of-training-corpus-size-on-classifier-performance-for-natural-language-processing/">"Mitigating the Paucity-of-Data Problem: Exploring the Effect of Training Corpus Size on Classifier Performance for Natural Language Processing" de Michele Banko y Eric Brill</a> se prueban varios modelos complejos y se observa que su desempeño tiende a ser el mismo, y además crece monotónicamente con la cantidad de ejemplos de entrenamiento.
</p>
</div>
</div>
</div>

<div id="outline-container-orge0b59fa" class="outline-3">
<h3 id="orge0b59fa"><span class="section-number-3">8.7</span> Review</h3>
<div class="outline-text-3" id="text-8-7">
</div>
<div id="outline-container-org99a90a7" class="outline-4">
<h4 id="org99a90a7"><span class="section-number-4">8.7.1</span> Quiz: machine learning system design</h4>
</div>
</div>
</div>

<div id="outline-container-orgbc17175" class="outline-2">
<h2 id="orgbc17175"><span class="section-number-2">9</span> Semana 7</h2>
<div class="outline-text-2" id="text-9">
<p>
Vamos a ver <i>SVMs</i>: máquinas de vector soporte / máquinas de soporte vectorial.
</p>
</div>

<div id="outline-container-org2379d94" class="outline-3">
<h3 id="org2379d94"><span class="section-number-3">9.1</span> Large margin classification</h3>
<div class="outline-text-3" id="text-9-1">
</div>
<div id="outline-container-orgd08433a" class="outline-4">
<h4 id="orgd08433a"><span class="section-number-4">9.1.1</span> Optimization objective</h4>
<div class="outline-text-4" id="text-9-1-1">
<p>
Vamos a ver un algoritmo de aprendizaje supervisado más: las máquinas de soporte vectorial. Primero definimos una función de costo a optimizar, que es similar a la que usamos para regresión logística.
</p>

<p>
\[  J(\theta) = C \sum_{i=1}^m \left[ y^{(i)} cost_1(\theta x^{(i)}) + (1-y^{(i)}) cost_0(1 - \theta x^{(i)}) \right]  + \frac{1}{2}  \sum_{v=1}^{n} \theta_v  \]
</p>

<ul class="org-ul">
<li>\(C\) es equivalente a \(1/\lambda\), y es un factor que sirve para ponderar la optimización del primer término sobre el otro.</li>
<li>Las funciones \(cost_0\) y \(cost_1\) son muy similares al menos logaritmo de la función logística (lo que estaba ahí en la función de costo que usamos para regresión logística).</li>
</ul>

<p>
La función de hipótesis (que todavía no vemos) no emite probabilidades, sino una salida discreta, que definimos con un umbral en \(0\):
</p>

<p>
\[  h_\theta(x) = 1 \quad si \quad \theta^T x \ge 0   \]
\[  h_\theta(x) = 0 \quad si \quad \theta^T x \lt 0  \]
</p>
</div>
</div>

<div id="outline-container-org611eec5" class="outline-4">
<h4 id="org611eec5"><span class="section-number-4">9.1.2</span> Large margin intuition</h4>
</div>

<div id="outline-container-org249e2c9" class="outline-4">
<h4 id="org249e2c9"><span class="section-number-4">9.1.3</span> Mathematics behind large margin classification</h4>
</div>
</div>

<div id="outline-container-org37ab45e" class="outline-3">
<h3 id="org37ab45e"><span class="section-number-3">9.2</span> Kernels</h3>
<div class="outline-text-3" id="text-9-2">
</div>
<div id="outline-container-org795a3d3" class="outline-4">
<h4 id="org795a3d3"><span class="section-number-4">9.2.1</span> Kernels I</h4>
</div>

<div id="outline-container-org9502002" class="outline-4">
<h4 id="org9502002"><span class="section-number-4">9.2.2</span> Kernels II</h4>
</div>
</div>

<div id="outline-container-orgf6e6545" class="outline-3">
<h3 id="orgf6e6545"><span class="section-number-3">9.3</span> SVMs in practice</h3>
<div class="outline-text-3" id="text-9-3">
</div>
<div id="outline-container-orgad1eea0" class="outline-4">
<h4 id="orgad1eea0"><span class="section-number-4">9.3.1</span> Using an SVM</h4>
</div>
</div>

<div id="outline-container-org5d227d2" class="outline-3">
<h3 id="org5d227d2"><span class="section-number-3">9.4</span> Review</h3>
<div class="outline-text-3" id="text-9-4">
</div>
<div id="outline-container-orgecd6ffe" class="outline-4">
<h4 id="orgecd6ffe"><span class="section-number-4">9.4.1</span> Quiz: support vector machines</h4>
</div>

<div id="outline-container-org36fdbf7" class="outline-4">
<h4 id="org36fdbf7"><span class="section-number-4">9.4.2</span> Programming assignmentL SVMs</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Pablo Aguado</p>
<p class="date">Created: 2020-05-11 lun 23:25</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
