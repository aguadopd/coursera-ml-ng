<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-04-16 jue 03:33 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notas del curso Machine Learning de Andrew Ng en Coursera</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Pablo Aguado" />
<meta name="description" content="Mis notas."
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Notas del curso Machine Learning de Andrew Ng en Coursera</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8754c16">1. Info</a></li>
<li><a href="#org1f0336d">2. Ideas</a></li>
<li><a href="#org3ad1da8">3. Semana 1</a>
<ul>
<li><a href="#orge0d7198">3.1. Introduction</a>
<ul>
<li><a href="#org0de9f62">3.1.1. Video: Welcome</a></li>
<li><a href="#org71f26a6">3.1.2. Video: What is Machine Learning</a></li>
<li><a href="#org47edbdd">3.1.3. Reading: What is Machine Learning?</a></li>
<li><a href="#orgd0714be">3.1.4. Video: Supervised Learning</a></li>
<li><a href="#org3dc92b2">3.1.5. Video: Unsupervised Learning</a></li>
</ul>
</li>
<li><a href="#org415cd89">3.2. Model and cost function</a>
<ul>
<li><a href="#orgac2af05">3.2.1. Video: Model representation</a></li>
<li><a href="#org15c2751">3.2.2. Reading: Model representation</a></li>
<li><a href="#org93e1fc4">3.2.3. Video: Cost function</a></li>
<li><a href="#org0bf93e3">3.2.4. Reading: Cost function</a></li>
<li><a href="#org93698fc">3.2.5. Video: Cost function intuition I</a></li>
<li><a href="#orge406307">3.2.6. Reading: Cost function intuition I</a></li>
<li><a href="#org0c7bf5b">3.2.7. Video: Cost function intuition II</a></li>
<li><a href="#orgb5740a8">3.2.8. Reading: Cost function intuition II</a></li>
</ul>
</li>
<li><a href="#org702c5cf">3.3. Parameter learning</a>
<ul>
<li><a href="#org0da2318">3.3.1. Video: Gradient descent</a></li>
<li><a href="#orgc8142c3">3.3.2. Reading: Gradient descent</a></li>
<li><a href="#org61d4c21">3.3.3. Video: Gradient descent intuition</a></li>
<li><a href="#orgb1239c4">3.3.4. Reading: Gradient descent intuition</a></li>
<li><a href="#org328f8ec">3.3.5. Video: Gradient descent for linear regression</a></li>
<li><a href="#orgff79b32">3.3.6. Reading: Gradient descent for linear regression</a></li>
</ul>
</li>
<li><a href="#orge0bfa6c">3.4. Linear Algebra review</a>
<ul>
<li><a href="#orgdb319c4">3.4.1. Video: Matrix vector multiplication</a></li>
<li><a href="#orgd342457">3.4.2. Video: Matrix matrix multiplication</a></li>
<li><a href="#org474f926">3.4.3. Video: Inverse and transpose</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9061b6b">4. Semana 2</a>
<ul>
<li><a href="#org7f3b5e6">4.1. Environment setup instructions</a></li>
<li><a href="#org4d506c1">4.2. Multivariate linear regression</a>
<ul>
<li><a href="#org0fc2ca5">4.2.1. Video: Multivariate linear regression</a></li>
<li><a href="#org0d1c113">4.2.2. Reading: multiple features</a></li>
<li><a href="#org4e399b5">4.2.3. Video: Gradient descent for multiple features</a></li>
<li><a href="#orge92239a">4.2.4. Reading: Gradient descent for multiple features</a></li>
<li><a href="#org95742ff">4.2.5. Video: Gradient descent in practice I - Feature scaling</a></li>
<li><a href="#org891d3f9">4.2.6. Reading: Gradient descent in practice I - Feature scaling</a></li>
<li><a href="#org9f72a84">4.2.7. Video: Gradient descent in practice II - Learning rate</a></li>
<li><a href="#orgfed8c4d">4.2.8. Reading: Gradient descent in practice II - Learning rate</a></li>
<li><a href="#org6c7d709">4.2.9. Video: Features and polynomial regression</a></li>
<li><a href="#orgfa7b392">4.2.10. Reading: Features and polynomial regression</a></li>
</ul>
</li>
<li><a href="#orgfc44757">4.3. Computing parameters analitically</a>
<ul>
<li><a href="#org30c5322">4.3.1. Video: Normal equation</a></li>
<li><a href="#orgdd1c738">4.3.2. Reading: Normal equation</a></li>
<li><a href="#org90043ab">4.3.3. Video: Normal equation noninvertibility</a></li>
<li><a href="#org767a4f2">4.3.4. Reading: Normal equation noninvertibility</a></li>
</ul>
</li>
<li><a href="#org5079db7">4.4. Submitting programming assignments</a></li>
<li><a href="#org0403f1a">4.5. Review</a></li>
<li><a href="#org4fb9381">4.6. Octave/Matlab tutorial</a></li>
<li><a href="#org212ec28">4.7. Review</a>
<ul>
<li><a href="#org616bf13">4.7.1. Programming assignment 1: linear regression</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1239278">5. Semana 3</a>
<ul>
<li><a href="#orgde8b2dd">5.1. Classification and representation</a>
<ul>
<li><a href="#orgfe7abfa">5.1.1. Classification</a></li>
<li><a href="#org2c9cde2">5.1.2. Hypothesis representation</a></li>
<li><a href="#org5867a3e">5.1.3. Decision boundary</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org703cd3a">6. Semana 4</a></li>
</ul>
</div>
</div>


<div id="outline-container-org8754c16" class="outline-2">
<h2 id="org8754c16"><span class="section-number-2">1</span> Info</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li><a href="https://www.coursera.org/learn/machine-learning">https://www.coursera.org/learn/machine-learning</a></li>
<li><a href="https://www.coursera.org/learn/machine-learning/discussions/all/threads/v2YppY8FEeWIeBJxvl1elQ">Important notes for new ML students</a>
<ul class="org-ul">
<li>Hay más <i>test cases</i> en los Recursos del curso.</li>
<li><b>Hay que usar Octave &gt; 4.0.0</b></li>
<li><a href="https://learner.coursera.help/hc/en-us/articles/209818863-Coursera-Honor-Code">Cousera Honor Code</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org1f0336d" class="outline-2">
<h2 id="org1f0336d"><span class="section-number-2">2</span> Ideas</h2>
<div class="outline-text-2" id="text-2">
<p>
Ideas mías a lo largo del curso.
</p>

<ol class="org-ol">
<li>Probar <a href="https://github.com/google-research/google-research/blob/master/automl_zero/README.md">AutoML-Zero</a>.</li>
<li>Buscar clusters en espacios transformados y muy transformados. Ej: Fourier, Fourier de Fourier, Cepstrum&#x2026;</li>
</ol>
</div>
</div>


<div id="outline-container-org3ad1da8" class="outline-2">
<h2 id="org3ad1da8"><span class="section-number-2">3</span> Semana 1</h2>
<div class="outline-text-2" id="text-3">
<p>
Intro, regresión lineal, repaso de Álgebra.
</p>


<ul class="org-ul">
<li><a href="https://www.coursera.org/learn/machine-learning/discussions/weeks/1/threads/hAp4LT1SEeaL_xIEq4QdBw">FAQ de la semana 1</a></li>
</ul>
</div>

<div id="outline-container-orge0d7198" class="outline-3">
<h3 id="orge0d7198"><span class="section-number-3">3.1</span> Introduction</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org0de9f62" class="outline-4">
<h4 id="org0de9f62"><span class="section-number-4">3.1.1</span> Video: Welcome</h4>
</div>

<div id="outline-container-org71f26a6" class="outline-4">
<h4 id="org71f26a6"><span class="section-number-4">3.1.2</span> Video: What is Machine Learning</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>Los algoritmos más importantes son el aprendizaje supervisado y el aprendizaje no supervisado. Es esta además la clasificación más general de algoritmos.
<ul class="org-ul">
<li>Otros son el aprendizaje por refuerzo y los sistemas de recomendación.</li>
</ul></li>
<li>Hay que aprender las herramientas, pero <b>es muy importante saber cómo y cuándo usarlas</b>.</li>
<li>Sea una máquina que debe hacer una tarea T, con un desempeño P y que la exponemos a experiencias (instancias) E de esa tarea T. Se dice que la computadora aprende si su desempeño P en la tarea T <i>aumenta proporcionalmente a la cantidad de experiencias E</i>.</li>
<li>Otra definición de aprendizaje automático es la capacidad (de la computadora) de aprender a resolver problemas para los que no fue programada. ~</li>
</ul>
</div>
</div>

<div id="outline-container-org47edbdd" class="outline-4">
<h4 id="org47edbdd"><span class="section-number-4">3.1.3</span> Reading: What is Machine Learning?</h4>
</div>

<div id="outline-container-orgd0714be" class="outline-4">
<h4 id="orgd0714be"><span class="section-number-4">3.1.4</span> Video: Supervised Learning</h4>
<div class="outline-text-4" id="text-3-1-4">
<ul class="org-ul">
<li>En el aprendizaje supervisado, le mostramos al programa ejemplos de entradas y sus correspondientes salidas/respuestas correctas. Ya sabemos cómo son las respuestas corectas; tenemos la idea de que hay una relación entre las entradas y las salidas. Dado un conjunto de entradas y salidas, intentamos obtener un modelo que permita predecir/inferir las salidas a nuevos datos de entrada.</li>
<li>Los problemas de aprendizaje supervisado se clasifican en problemas de regresión y de clasificación:
<ul class="org-ul">
<li>Problema de <b>regresión</b> si el conjunto imagen es continuo. La salida es una variable numérica.</li>
<li>Problema de <b>clasificación</b> si el conjunto imagen es discreto. La salida es una variable categórica.</li>
</ul></li>
<li>Los algoritmos de Máquinas de Vector Soporte permiten <i><b>infinitos</b></i> valores de entrada.</li>
</ul>
</div>

<ol class="org-ol">
<li><a id="org371db07"></a><span class="todo TODO">TODO</span> Leer <a href="https://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression">https://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression</a><br /></li>

<li><a id="org5d5e63a"></a><span class="todo TODO">TODO</span> Leer <a href="https://datascience.stackexchange.com/questions/25298/how-to-know-when-to-treat-a-problem-as-a-classification-task-or-a-regression-tas">https://datascience.stackexchange.com/questions/25298/how-to-know-when-to-treat-a-problem-as-a-classification-task-or-a-regression-tas</a><br /></li>
</ol>
</div>

<div id="outline-container-org3dc92b2" class="outline-4">
<h4 id="org3dc92b2"><span class="section-number-4">3.1.5</span> Video: Unsupervised Learning</h4>
<div class="outline-text-4" id="text-3-1-5">
<ul class="org-ul">
<li>En el aprendizaje no supervisado, le damos datos al programa con la intención de encontrar estructuras subyacentes, patrones.</li>
<li>Un ejemplo típico es el <i>clustering</i> o agrupamiento de datos.</li>
<li>En el ejemplo de sonido Cocktail Party, según <a href="https://www.coursera.org/learn/machine-learning/discussions/weeks/1/threads/hAp4LT1SEeaL_xIEq4QdBw">FAQ de la semana 1</a>, lo que usan es <i>Principal Component Analysis, PCA, a mathematical trick that takes two sets of correlated data, and returns two new sets of data that are not correlated.</i> No lo había visto así antes, creo&#x2026;</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org415cd89" class="outline-3">
<h3 id="org415cd89"><span class="section-number-3">3.2</span> Model and cost function</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Vemos la regresión lineal como primer algoritmo de aprendizaje supervisado.
</p>
</div>

<div id="outline-container-orgac2af05" class="outline-4">
<h4 id="orgac2af05"><span class="section-number-4">3.2.1</span> Video: Model representation</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
Un poco de nomenclatura:
</p>

<ul class="org-ul">
<li>\(m\): cantidad de ejemplos de entrenamiento.</li>
<li>\(\vec{x}\): entradas / descriptores / <i>features</i></li>
<li>\(\vec{y}\): salidas. \(\hat{\vec{y}}\) son las salidas estimadas.</li>
<li>\(h_\theta\): función de hipótesis, de estimación. Tiene parámetros \(\vec{\theta}\). Entonces tenemos que \( \hat{y}^{(i)} = h_\theta(x^{(i)}) = h(x,\theta) \)</li>
<li>\(x^{(i)}\): entrada $i$-ésima del vector de entradas, con índices empezando en 1.
<ul class="org-ul">
<li>\((x^{(i)},y^{(i)})\) es un ejemplo de entrenamiento.</li>
</ul></li>
<li>Para regresión lineal de una variable tenemos entonces</li>
</ul>
<p>
\[ \hat{y}^{(i)} = h_\theta(x^{(i)}) = \theta_0 + \theta_1 * x^{(i)} \]
</p>
</div>
</div>

<div id="outline-container-org15c2751" class="outline-4">
<h4 id="org15c2751"><span class="section-number-4">3.2.2</span> Reading: Model representation</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li>\(X\): el espacio de los valores de entrada.</li>
<li>\(Y\): el espacio de los valores de salida.</li>
<li>El objetivo del aprendizaje supervisado es encontrar una función \(h: X \rightarrow Y\) que sea buena prediciendo salidas a partir de entradas.</li>
</ul>
</div>
</div>

<div id="outline-container-org93e1fc4" class="outline-4">
<h4 id="org93e1fc4"><span class="section-number-4">3.2.3</span> Video: Cost function</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Formalizamos el problema del aprendizaje como la minimización de una función de costo \(J(\vec{\theta})\). La función de costo habitual y recomendada para problemas de regresión lineal es el <b>error cuadrático medio</b> (<a href="https://en.wikipedia.org/wiki/Mean_squared_error"><i>Mean Squared Error</i></a> o <i>Mean Squared Deviation</i>).
</p>

<p>
Para un predictor como lo es \(h_\theta\), el MSE se define como
\[ MSE = \frac{1}{N} (\sum_{1}^{N}Y_i - \hat{Y}_i )^2\]
</p>

<p>
En nuestro caso vamos a definir a la función de costo para este problema de regresión lineal univariable como
</p>

<p>
\[ J(\theta_0 , \theta_1) = \frac{1}{2m} \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} )^2  \]
\[ J(\theta_0 , \theta_1) =  \frac{1}{2m} \sum_{i=1}^m( \theta_0 + \theta_1 * x^{(i)} - y^{(i)} )^2 \]
</p>

<ul class="org-ul">
<li>El factor \(1/2\) es para ahorrar cálculos, puesto que en redes neuronales al hacer <i>backpropagation</i> o <i>gradient descent</i> hay que derivar esta función de error y entonces con este \(1/2\) simplificamos el \(2\) de la derivada del cuadrado.</li>
</ul>

<p>
La optimización es entonces encontrar los parámetros \(\theta\) que minimizan la función de costo:
\[ \underset{\theta_0 , \theta_1}{\text{min}}  J(\theta_0 , \theta_1)\]
</p>

<hr />

<p>
<i>En las notas del curso encontramos la forma matricial, que luego usamos para hacer descenso por el gradiente de forma matricial. Lo pongo acá por completitud</i>.
</p>

<p>
MSE: \[ J(\theta) = \frac{1}{2m} (X\times\theta-Y)^T(X\times\theta-Y)  \]
</p>

<p>
El producto implica la sumatoria y el cuadrado elemento a elemento.
</p>

<hr />
</div>
</div>

<div id="outline-container-org0bf93e3" class="outline-4">
<h4 id="org0bf93e3"><span class="section-number-4">3.2.4</span> Reading: Cost function</h4>
</div>

<div id="outline-container-org93698fc" class="outline-4">
<h4 id="org93698fc"><span class="section-number-4">3.2.5</span> Video: Cost function intuition I</h4>
</div>

<div id="outline-container-orge406307" class="outline-4">
<h4 id="orge406307"><span class="section-number-4">3.2.6</span> Reading: Cost function intuition I</h4>
</div>

<div id="outline-container-org0c7bf5b" class="outline-4">
<h4 id="org0c7bf5b"><span class="section-number-4">3.2.7</span> Video: Cost function intuition II</h4>
</div>

<div id="outline-container-orgb5740a8" class="outline-4">
<h4 id="orgb5740a8"><span class="section-number-4">3.2.8</span> Reading: Cost function intuition II</h4>
<div class="outline-text-4" id="text-3-2-8">
<p>
De <a href="https://es.wikipedia.org/wiki/Isol%C3%ADnea">isolíneas / curvas de nivel</a>.
</p>
</div>
</div>
</div>


<div id="outline-container-org702c5cf" class="outline-3">
<h3 id="org702c5cf"><span class="section-number-3">3.3</span> Parameter learning</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-org0da2318" class="outline-4">
<h4 id="org0da2318"><span class="section-number-4">3.3.1</span> Video: Gradient descent</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
El descenso por el gradiente es un algoritmo de optimización que vamos a usar (entre otras cosas) para minimizar la función de costo.
</p>

<p>
Hacer \[ \vec{\theta}[n+1] := \vec{\theta}[n] - \alpha \frac{\delta J(\vec{\theta})}{\delta\theta}  \]
</p>

<p>
(expresado de otra manera)
</p>

<p>
\[ {\theta}_i[n+1] := \vec{\theta}[n] - \alpha \frac{\delta J(\vec{\theta})}{\delta\theta}  \]
</p>

<p>
Hasta que \[  \vec{\theta}[n+1] - \vec{\theta}[n] < \epsilon \]
</p>

<ul class="org-ul">
<li>Nomenclatura: usamos \(:=\) como operador de asignación.</li>
<li>\(\alpha\) es la tasa de aprendizaje o <i>learning rate</i> del algoritmo.</li>
</ul>

<p>
Para calcular la derivada hacemos derivadas parciales. Actualizamos los parámetros simultáneamente en cada paso. Si actualizamos de a uno estamos haciendo otro algoritmo, que probablemente también converja pero es distinto.
</p>

<p>
Cuando la función de costo es el error cuadrático medio (<i>MSE</i>), la fórmula de actualización queda:
</p>

<p>
\[ \theta_i[n+1] := \vec{\theta}[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) \theta_i  \]
</p>
</div>
</div>

<div id="outline-container-orgc8142c3" class="outline-4">
<h4 id="orgc8142c3"><span class="section-number-4">3.3.2</span> Reading: Gradient descent</h4>
</div>

<div id="outline-container-org61d4c21" class="outline-4">
<h4 id="org61d4c21"><span class="section-number-4">3.3.3</span> Video: Gradient descent intuition</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>Si \(\alpha\) es muy grande, el algoritmo puede oscilar o incluso diverger.</li>
<li>Si \(\alpha\) es muy chica, puede tardar mucho en converger.</li>
<li>Con \(\alpha\) fija, los "pasos" que da el algoritmo son cada vez más chicos a medida que la función de costo se aproxima a un mínimo local.</li>
</ul>
</div>
</div>

<div id="outline-container-orgb1239c4" class="outline-4">
<h4 id="orgb1239c4"><span class="section-number-4">3.3.4</span> Reading: Gradient descent intuition</h4>
</div>

<div id="outline-container-org328f8ec" class="outline-4">
<h4 id="org328f8ec"><span class="section-number-4">3.3.5</span> Video: Gradient descent for linear regression</h4>
<div class="outline-text-4" id="text-3-3-5">
<p>
Dice Andrew cerca del minuto 4:40:
</p>

<blockquote>
<p>
But, it turns out that that the cost function for
linear regression is always going to be a bow shaped function like this.
The technical term for this is that this is called a convex function.
</p>
</blockquote>

<p>
¿Por qué?
</p>

<ul class="org-ul">
<li>La función de costo \(J(\vec{\theta})\) es el error cuadrático medio (MSE).</li>
<li>El MSE es cuadrático respecto a los parámetros siempre y cuando estos sean lineales, de grado 1. <b>La función de hipótesis debe ser lineal respecto a los parámetros para que la función de costo sea cuadrática</b>.
<ul class="org-ul">
<li>Sea por ejemplo \[ h(x,y) =  a.x^2 + b.y^2 - c.x^2 y^2 \]. Esta función tiene más de un mínimo.</li>
</ul></li>
</ul>


<div class="figure">
<p><img src="imgs/001-01-nolineal.gif" alt="001-01-nolineal.gif" />
</p>
</div>

<ul class="org-ul">
<li>Su MSE quedaría algo como \[ x^4 + 2 x^2 y^2 - 2 x^4 y^2 + y^4 - 2 x^2 y^4 + x^4 y^4  \] (sólo <a href="https://www.wolframalpha.com/input/?i=%28x%5E2+%2B+y%5E2+-+x%5E2y%5E2%29%5E2">la elevé al cuadrado</a>)</li>
</ul>


<div class="figure">
<p><img src="imgs/001-02-nolineal-cuadrado.gif" alt="001-02-nolineal-cuadrado.gif" />
</p>
</div>

<hr />

<p>
Hay otras formas de estimar los parámetros (regresores). Una de ellas es el método de los mínimos cuadrados (<a href="https://en.wikipedia.org/wiki/Ordinary_least_squares">/Ordinary Least Squares</a>/). El descenso por el gradiente es más fácil de computar que OLS, en el caso de datasets grandes.
</p>

<p>
En realidad todo lo que vimos es descenso por el gradiente por lotes, o <b><i>batch gradient descent</i></b>, que es cuando la función de costo se optimiza usando todas las entradas disponibles. Esto es costoso.
</p>
</div>



<ol class="org-ol">
<li><a id="org5384b21"></a><span class="todo TODO">TODO</span> Leer más de <a href="https://en.wikipedia.org/wiki/Linear_regression">regresión lineal</a><br /></li>
</ol>



<li><a id="orgb883359"></a>Regresión lineal<br /></li>
</ol>
</div>



<div id="outline-container-orgff79b32" class="outline-4">
<h4 id="orgff79b32"><span class="section-number-4">3.3.6</span> Reading: Gradient descent for linear regression</h4>
</div>
</div>

<div id="outline-container-orge0bfa6c" class="outline-3">
<h3 id="orge0bfa6c"><span class="section-number-3">3.4</span> Linear Algebra review</h3>
<div class="outline-text-3" id="text-3-4">
</div>
<div id="outline-container-orgdb319c4" class="outline-4">
<h4 id="orgdb319c4"><span class="section-number-4">3.4.1</span> Video: Matrix vector multiplication</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>Más adelante vamos a ver por qué es mejor vectorizar calculos en lugar de iterar.</li>
<li>Hace un truco interesante que es incluir a la ordenada al origen dentro del vector de parámetros &#x2014;en realidad está bien, es un parámetro calculado&#x2014;, y luego introduce una columna de \(1\)s en la matriz de entradas.
<ul class="org-ul">
<li>La alternativa es sumar la columna aparte. \(A*X + B\)</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgd342457" class="outline-4">
<h4 id="orgd342457"><span class="section-number-4">3.4.2</span> Video: Matrix matrix multiplication</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>Acá hace el mismo truco pero para hacer varias predicciones a la vez: usa varios modelos y varias entradas.</li>
</ul>
</div>
</div>

<div id="outline-container-org474f926" class="outline-4">
<h4 id="org474f926"><span class="section-number-4">3.4.3</span> Video: Inverse and transpose</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
Interesante:
</p>
<blockquote>
<p>
But the intuition if you want is that you can think of matrices as not have an inverse that is somehow too close to zero in some sense.
</p>
</blockquote>

<ul class="org-ul">
<li>Las matrices que no tienen inversa son matrices <i>singulares</i> o <i>degeneradas</i>.
<ul class="org-ul">
<li>Asumo que se refiere a matrices cuadradas, que podrían tener inversa.</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org9061b6b" class="outline-2">
<h2 id="org9061b6b"><span class="section-number-2">4</span> Semana 2</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org7f3b5e6" class="outline-3">
<h3 id="org7f3b5e6"><span class="section-number-3">4.1</span> Environment setup instructions</h3>
</div>

<div id="outline-container-org4d506c1" class="outline-3">
<h3 id="org4d506c1"><span class="section-number-3">4.2</span> Multivariate linear regression</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org0fc2ca5" class="outline-4">
<h4 id="org0fc2ca5"><span class="section-number-4">4.2.1</span> Video: Multivariate linear regression</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
En la regresión lineal multivariable o regresión lineal múltiple, tenemos varios valores de entrada o descriptores. Para tener una notación más compacta y conveniente, vamos a definir:
</p>
<ul class="org-ul">
<li>\(\theta_0=1\) ;</li>
<li>\(n\) es la cantidad de entradas, descriptores;</li>
<li>vamos a usar \(\vec{\theta}\) con índice \(0\);</li>
<li>y \(\vec{\theta}_j^{(i)}\) es el elemento j-ésimo del ejemplo i-ésimo.</li>
</ul>

<p>
Entonces \(\vec{\theta}\) tiene \(n+1\) elementos y  \[ \vec{\theta} = 1 + \theta_1 + \theta_2 + \dots + \theta_n  \]
</p>


<p>
Y luego \[ \vec{h_\theta}(\vec{x}) = \vec{\theta}^T \cdot \vec{x}  = \vec{x}^T \cdot \vec{\theta}  \]
</p>

<ul class="org-ul">
<li>Intuición para el ejemplo de estimar el precio de un inmueble: \(\theta_0\) es el precio base.</li>
</ul>

<hr />

<p>
<i>En <a href="#org30c5322">4.3.1</a> se introduce notación matricial que luego en el ejercicio 1 usamos para expresar todo de forma vectorizada. Dejo todo acá para más completitud</i>.
</p>

<p>
MSE: \[ J(\theta) = \frac{1}{2m} (X\times\theta-Y)^T(X\times\theta-Y)  \]
</p>

<hr />
</div>
</div>

<div id="outline-container-org0d1c113" class="outline-4">
<h4 id="org0d1c113"><span class="section-number-4">4.2.2</span> Reading: multiple features</h4>
</div>

<div id="outline-container-org4e399b5" class="outline-4">
<h4 id="org4e399b5"><span class="section-number-4">4.2.3</span> Video: Gradient descent for multiple features</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
La regla de actualización era:
</p>

<p>
\[ \vec{\theta}[n+1] := \vec{\theta}[n] - \\alpha \frac{\delta J(\vec{\theta})}{\delta\theta}  \]
</p>

<p>
Y para cuando la función de costo es el error cuadrático medio (MSE), queda (para actualización con todos los \(m\) ejemplos):
</p>

<p>
\[ \vec{\theta}_j[n+1] := \vec{\theta}[n] - \frac{\alpha}{m} \sum_{i=1}^{m} \left( ( \vec{\theta}^T \cdot \vec{x}^{(i)} - y^{(i)}  ) x_j^{(i)} \right) \]
</p>

<ul class="org-ul">
<li>Puedo ver el factor de avance luego de \(\alpha\) como el aporte al error medio que hizo el descriptor \(x_j\) .
<ul class="org-ul">
<li>El producto vectorial y la resta son el error medio para ese vector de entrada.</li>
<li>El factor \(x_j\) es el aporte de ese elemento, en esa dirección.
<ul class="org-ul">
<li>La dirección final es la suma vectorial de los elementos.</li>
</ul></li>
</ul></li>
</ul>

<hr />

<p>
<i>La versión vectorizada/matricial del algoritmo está en las notas del curso y después la usamos en el ejercicio de programación 1. La dejo acá por completitud</i>.
</p>

<p>
\[ \theta_{n \times 1}[i+1] = \theta_{n \times 1}[i] - \frac{\alpha}{m} X_{m \times n}^T (X_{m \times n} \theta_{n \times 1} - Y_{m \times 1} )_{m \times 1} \]
\[ \theta_{}[i+1] = \theta[i] - \frac{\alpha}{m} X^T (X \theta - Y) \]
</p>

<hr />
</div>

<ol class="org-ol">
<li><a id="orgb1ad99b"></a><span class="todo TODO">TODO</span> EL ERROR ES MAYPR CUANDO HAY CORRELACIÓN ENTRE DESCRIPTORES Y PARÁMETROS.<br /></li>
</ol>
</div>

<div id="outline-container-orge92239a" class="outline-4">
<h4 id="orge92239a"><span class="section-number-4">4.2.4</span> Reading: Gradient descent for multiple features</h4>
</div>

<div id="outline-container-org95742ff" class="outline-4">
<h4 id="org95742ff"><span class="section-number-4">4.2.5</span> Video: Gradient descent in practice I - Feature scaling</h4>
<div class="outline-text-4" id="text-4-2-5">
<ul class="org-ul">
<li>Al parecer, el algoritmo de descenso por el gradiente converge <b>bastante más rápidamente</b> si los descriptores están en el mismo orden de magnitud.
<ul class="org-ul">
<li>Andrew propone que estén <i>más o menos</i> en el rango \(-3 < x_j < 3\) y duda si \(-\frac{1}{3} < x < \frac{1}{3}\)</li>
</ul></li>
<li>Para esto se suele normalizar cada descriptor respecto al rango de sí mismo en la muestra (los m ejemplos de entrada) o respecto a la desviación estándar. Esto se llama <b><i>feature scaling</i></b>.</li>
<li>Otra práctica habitual es centrar en cero los valores, para lo cual se resta la media de la muestra. Esto se llama <b><i>mean normalization</i></b>.</li>
</ul>
</div>

<ol class="org-ol">
<li><a id="orgab68ce0"></a>Más de feature scaling y mean normalization<br />
<div class="outline-text-5" id="text-4-2-5-1">
<p>
De la ecuación de actualización de los parámetros de la ecuación de hipótesis infiero que el vector se mueve <span class="underline">más rápidamente</span> en dirección de los parámetros más grandes. Sin embargo en <a href="#org891d3f9">4.2.6</a> dice:
</p>

<blockquote>
<p>
This is because θ will descend quickly on small ranges and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven.
</p>
</blockquote>
</div>

<ol class="org-ol">
<li><a id="org1e0625a"></a><span class="todo TODO">TODO</span> Averiguar más de esto. ¿Por qué se hace? ¿Tienen que ser de la misma magnitud o ser chicos?<br /></li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-org891d3f9" class="outline-4">
<h4 id="org891d3f9"><span class="section-number-4">4.2.6</span> Reading: Gradient descent in practice I - Feature scaling</h4>
</div>


<div id="outline-container-org9f72a84" class="outline-4">
<h4 id="org9f72a84"><span class="section-number-4">4.2.7</span> Video: Gradient descent in practice II - Learning rate</h4>
<div class="outline-text-4" id="text-4-2-7">
<ul class="org-ul">
<li>Si la función de costo \(J(\vec{\theta})\) diverge u oscila, entonces mi tasa de aprendizaje \(\alpha\) es muy grande. Si es muy chica, converge lentamente.</li>
<li>Puedo verlo graficando la función de costo.</li>
<li>Elegir el valor de \(\alpha\) es, a priori, por prueba y error. <b><i>¿Habrá heurísticas para determinar un buen valor inicial?</i></b></li>
<li>La condición de convergencia también suele depender del problema. Andrew habla de valores absolutos&#x2026; <b><i>¿por qué no usar un \(\epsilon\) relativo?</i></b></li>
</ul>
</div>
</div>

<div id="outline-container-orgfed8c4d" class="outline-4">
<h4 id="orgfed8c4d"><span class="section-number-4">4.2.8</span> Reading: Gradient descent in practice II - Learning rate</h4>
</div>


<div id="outline-container-org6c7d709" class="outline-4">
<h4 id="org6c7d709"><span class="section-number-4">4.2.9</span> Video: Features and polynomial regression</h4>
</div>

<div id="outline-container-orgfa7b392" class="outline-4">
<h4 id="orgfa7b392"><span class="section-number-4">4.2.10</span> Reading: Features and polynomial regression</h4>
<div class="outline-text-4" id="text-4-2-10">
<ul class="org-ul">
<li>La regresión lineal es ajustar un modelo lineal, de grado 1, una combinación lineal entre las entradas y parámetros.</li>
<li>Podemos ajustar modelos no lineales como hipótesis si codificamos estas no linealidades dentro de los descriptores. Por ejemplo, para el caso de la estimación de precios de casas, un posible descriptor podría ser el cuadrado del área, y ahí estamos incluyendo algo cuadrático en el modelo.</li>
<li>Al incluir las no linealidades en los descriptores, pero todavía usando los parámetros como multiplicadores de orden 1, podemos seguir usando el descenso por el gradiente para optimizar.</li>
<li>Andrew habla también de usar relaciones entre entradas básicas para construir otras entradas. Por ejemplo, el producto de dos descriptores hace un nuevo descriptor que codifica otra relación.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgfc44757" class="outline-3">
<h3 id="orgfc44757"><span class="section-number-3">4.3</span> Computing parameters analitically</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-org30c5322" class="outline-4">
<h4 id="org30c5322"><span class="section-number-4">4.3.1</span> Video: Normal equation</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>Otra forma de optimizar la regresión lineal es resolverla analíticamente con el método de los <a href="https://en.wikipedia.org/wiki/Least_squares">mínimos cuadrados</a> <a href="https://en.wikipedia.org/wiki/Linear_least_squares">lineales</a> / ecuación normal. Esto da la solución óptima (que existe porque hemos dicho que para regresión lineal es un espacio de búsqueda cónvexo con un solo mínimo).</li>
</ul>

<p>
\[  \vec{\theta} = ( X^T \times X )^{-1} \times X^T \times \vec{y}   \]
</p>

<p>
\[ X = \left[  x^{(i)}  \right]  \]
</p>

<ul class="org-ul">
<li>A \(X\) la llamamos <b><i>matriz de diseño</i></b>. Cada fila es un ejemplo, y tiene tamaño $m &times; n+1 $</li>

<li>La complejidad de invertir una matriz es \(O(n^3)\) y esto se pone lento para \(n > 10^5\). La complejidad del descenso por el gradiente, en cambio, es de \(O(k \cdot n^2)\).</li>

<li>\(( X^T \times X )^{-1} \times X^T = X^{+}\) es la <span class="underline"><a href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse">pseudoinversa</a></span> de \(X\), y el método de mínimos cuadrados no es más que una solución (óptima en el sentido del error cuadrático) de un sistema de ecuaciones sobredeterminado.

<ul class="org-ul">
<li>La pseudoinversa se puede calcular con <i>Singular Value Decomposition</i> o Descomposición QR, por ejemplo.</li>

<li>La regresión por mínimos cuadrados asume muchas cosas que no necesariamente siempre se cumplen. Ver la <a href="https://en.wikipedia.org/wiki/Robust_regression">regresión robusta</a> como alternativa.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgdd1c738" class="outline-4">
<h4 id="orgdd1c738"><span class="section-number-4">4.3.2</span> Reading: Normal equation</h4>
</div>

<div id="outline-container-org90043ab" class="outline-4">
<h4 id="org90043ab"><span class="section-number-4">4.3.3</span> Video: Normal equation noninvertibility</h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
Si \(( X^T \times X )\) no es invertible, entonces puede haber 2 problemas:
</p>

<ol class="org-ol">
<li>El sistema esta subdeterminado. Faltan ejemplos, \(m < n\) / tenemos muchos descriptores.
<ul class="org-ul">
<li>Después vamos a ver que se soluciona con <i>regularización</i>.</li>
</ul></li>
<li>Algunos descriptores están muy correlacionados / son linealmente dependientes.</li>
</ol>

<p>
Si no es invertible naturalmente (es singular o degenerada) igual se puede invertir con la pseudoinversa. Igual esto no sería problema si hubiésemos usado la pseudoinversa desde un principio en lugar de estar haciéndolo manualmente. Y, nuevamente, seguro hay métodos más robustos (aunque no hay que dejar de hacer análisis de la información con la que contamos).
</p>
</div>
</div>

<div id="outline-container-org767a4f2" class="outline-4">
<h4 id="org767a4f2"><span class="section-number-4">4.3.4</span> Reading: Normal equation noninvertibility</h4>
</div>
</div>


<div id="outline-container-org5079db7" class="outline-3">
<h3 id="org5079db7"><span class="section-number-3">4.4</span> Submitting programming assignments</h3>
</div>

<div id="outline-container-org0403f1a" class="outline-3">
<h3 id="org0403f1a"><span class="section-number-3">4.5</span> Review</h3>
</div>

<div id="outline-container-org4fb9381" class="outline-3">
<h3 id="org4fb9381"><span class="section-number-3">4.6</span> Octave/Matlab tutorial</h3>
<div class="outline-text-3" id="text-4-6">
<div class="org-src-container">
<pre class="src src-octave"><span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">Para ver una matriz/vector como p&#237;xeles con color</span>
A <span style="color: #4f97d7;">=</span> magic<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">9</span><span style="color: #4f97d7;">)</span>
figure
imagesc<span style="color: #4f97d7;">(</span>A<span style="color: #4f97d7;">)</span>
colorbar
colormap gray
</pre>
</div>
</div>
</div>


<div id="outline-container-org212ec28" class="outline-3">
<h3 id="org212ec28"><span class="section-number-3">4.7</span> Review</h3>
<div class="outline-text-3" id="text-4-7">
</div>
<div id="outline-container-org616bf13" class="outline-4">
<h4 id="org616bf13"><span class="section-number-4">4.7.1</span> Programming assignment 1: linear regression</h4>
<div class="outline-text-4" id="text-4-7-1">
<ul class="org-ul">
<li>Mi gradient descent convergía pero no al mismo resultado exacto, y más rápida o lentamente. Me faltaba el factor \(1/m\).</li>
<li>Armé una versión vectorizada del gradient descent pero es distinta a la propuesta:</li>
</ul>

<p>
La mía:
</p>

<ul class="org-ul">
<li>usé \(n\) como la longitud de \(\theta\), incluyendo los \(1\)s.</li>
</ul>

<div class="org-src-container">
<pre class="src src-octave">M <span style="color: #4f97d7;">=</span> length<span style="color: #4f97d7;">(</span>y<span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span> <span style="color: #2aa1ae; background-color: #292e34;">% number of training examples</span>
N <span style="color: #4f97d7;">=</span> length<span style="color: #4f97d7;">(</span>theta<span style="color: #4f97d7;">)</span><span style="color: #4f97d7;">;</span>
error <span style="color: #4f97d7;">=</span> <span style="color: #4f97d7;">(</span>X <span style="color: #4f97d7;">*</span> theta<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">-</span> y<span style="color: #4f97d7;">;</span>  <span style="color: #2aa1ae; background-color: #292e34;">% Mx1</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">ponderated_error = repmat(error, [1, N]) .* X;  % MxN</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">ponderated_error = error * ones(1,n) * X  % MxN, equivale al broadcasting</span>
ponderated_error <span style="color: #4f97d7;">=</span> error <span style="color: #4f97d7;">.*</span> X<span style="color: #4f97d7;">;</span>  <span style="color: #2aa1ae; background-color: #292e34;">% Broadcasting. MxN</span>
<span style="color: #2aa1ae; background-color: #292e34;">% </span><span style="color: #2aa1ae; background-color: #292e34;">gradient = sum(ponderated_error,1);  % 1xN</span>
gradient <span style="color: #4f97d7;">=</span> ones<span style="color: #4f97d7;">(</span><span style="color: #a45bad;">1</span><span style="color: #4f97d7;">,</span>M<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> ponderated_error<span style="color: #4f97d7;">;</span>  <span style="color: #2aa1ae; background-color: #292e34;">% 1xN, equivalente a la sumatoria</span>
theta <span style="color: #4f97d7;">=</span> theta <span style="color: #4f97d7;">-</span> <span style="color: #4f97d7;">(</span>alpha<span style="color: #4f97d7;">/</span>M<span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">*</span> gradient<span style="color: #4f97d7;">';</span>  <span style="color: #2aa1ae; background-color: #292e34;">% Nx1</span>
</pre>
</div>

<p>
\[ \theta_{n \times 1}[i+1] = \theta_{n \times 1}[i] - \frac{\alpha}{m} \left[ 1_{1 \times m} \left( X_{m \times n} \theta_{n \times 1} - Y_{m \times 1} \right)_{m \times 1} 1_{1 \times n} X_{m \times n} \right]^T  \]
</p>

<p>
La original es más compacta:
</p>

<p>
\[ \theta_{n \times 1}[i+1] = \theta_{n \times 1}[i] - \frac{\alpha}{m} X_{m \times n}^T (X_{m \times n} \theta_{n \times 1} - Y_{m \times 1} )_{m \times 1} \]
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org1239278" class="outline-2">
<h2 id="org1239278"><span class="section-number-2">5</span> Semana 3</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgde8b2dd" class="outline-3">
<h3 id="orgde8b2dd"><span class="section-number-3">5.1</span> Classification and representation</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-orgfe7abfa" class="outline-4">
<h4 id="orgfe7abfa"><span class="section-number-4">5.1.1</span> Classification</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
Vamos a ver la <b>regresión logística</b> que es un algoritmo de clasificación (aunque su nombre diga <i>regresión</i>).
</p>

<p>
La regresión lineal no es un buen método para la clasificación en variables discretas. Acá necesitamos algo más no lineal. Una opción es usar regresión lineal + un umbral arbitrario de separación, pero aún no es suficiente.
</p>

<p>
Vamos a ver clasificación binaria. Definimos como \(0\) y \(1\) a las clases. También usamos <b>etiqueta</b> para denominar a la salida \(h_\theta(x)\).
</p>
</div>
</div>

<div id="outline-container-org2c9cde2" class="outline-4">
<h4 id="org2c9cde2"><span class="section-number-4">5.1.2</span> Hypothesis representation</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
En clasificación binaria, los resultados observados sólo pueden tomar los valores \(0\) y \(1\), y por tanto nuestra función de hipótesis debería también sólo tomar esos valores.
</p>

<p>
Para empezar elegimos una función que esté acotada a ese rango. Una opción es la <b>función logística</b> o <b>sigmoidea</b>:
</p>

<p>
\[ h(z) = \frac{1}{1+e^z} \]
</p>

<p>
\[ h(\theta,x) = h_\theta(x) = \frac{1}{1+e^{\theta^T x} \]
</p>

<ul class="org-ul">
<li>Mapea los reales al intervalo \([0, 1]\).</li>
</ul>

<p>
Podemos interpretar los resultados como la probabilidad de que la hipótesis tome un valor, dada determinada entrada.
</p>

<ul class="org-ul">
<li>La suma de las probabilidades debe ser \(1\).</li>
</ul>
</div>


<ol class="org-ol">
<li><a id="org2452581"></a>La función logística o sigmoidea<br />
<div class="outline-text-5" id="text-5-1-2-1">
<ul class="org-ul">
<li>Se parece a la función cumulativa o función de distribución acumulada de una distribución normal/gaussiana.
<ul class="org-ul">
<li>Pero esta tiene una función explícita, mientras que la FDA de la gaussiana no tiene forma cerrada.</li>
<li>La función de densidad de probabilidad asociada "Se parece a la distribución normal en su forma, pero tiene colas más pesadas (y, por lo tanto, menor curtosis)". <a href="https://es.wikipedia.org/wiki/Distribuci%C3%B3n_log%C3%ADstica">Wikipedia: Distribución logística</a></li>
</ul></li>
<li>Puedo pensar que la FDP de la distribución logística me indica la cantidad de información que me da el valor de un descriptor. En el pico es donde más aporta; luego mientras más me alejo del centro, más claro es que es de una clase o de la otra.</li>
<li>Es una aproximación suave de la función escalón.</li>
</ul>


<div class="figure">
<p><img src="imgs/002-320px-Logistic-curve.svg.png" alt="002-320px-Logistic-curve.svg.png" />
</p>
</div>

<p>
\[ f(x) = \frac{L}{1+e^{-k(x-x_0)}}  \]
</p>

<ul class="org-ul">
<li>\(L\) es el valor máximo.</li>
<li>\(k\) es la tasa de crecimiento o pendiente de la curva.</li>
<li>\(x_0\) es el centro</li>
</ul>
</div>
</li>
</ol>
</div>

<div id="outline-container-org5867a3e" class="outline-4">
<h4 id="org5867a3e"><span class="section-number-4">5.1.3</span> Decision boundary</h4>
</div>
</div>
</div>

<div id="outline-container-org703cd3a" class="outline-2">
<h2 id="org703cd3a"><span class="section-number-2">6</span> Semana 4</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Pablo Aguado</p>
<p class="date">Created: 2020-04-16 jue 03:33</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
