#+author: Pablo Aguado
#+title: Notas del curso Machine Learning de Andrew Ng en Coursera
#+description: Mis notas.

#+STARTUP: indent content align entitiespretty


* Info

- https://www.coursera.org/learn/machine-learning
- [[https://www.coursera.org/learn/machine-learning/discussions/all/threads/v2YppY8FEeWIeBJxvl1elQ][Important notes for new ML students]]
  - Hay más /test cases/ en los Recursos del curso.
  - *Hay que usar Octave > 4.0.0*
  - [[https://learner.coursera.help/hc/en-us/articles/209818863-Coursera-Honor-Code][Cousera Honor Code]]

* Ideas

Ideas mías a lo largo del curso.

1. Probar [[https://github.com/google-research/google-research/blob/master/automl_zero/README.md][AutoML-Zero]].
2. Buscar clusters en espacios transformados y muy transformados. Ej: Fourier, Fourier de Fourier, Cepstrum...


* Semana 1

Intro, regresión lineal, repaso de Álgebra.


- [[https://www.coursera.org/learn/machine-learning/discussions/weeks/1/threads/hAp4LT1SEeaL_xIEq4QdBw][FAQ de la semana 1]]

** Introduction
*** Video: Welcome

*** Video: What is Machine Learning

- Los algoritmos más importantes son el aprendizaje supervisado y el aprendizaje no supervisado. Es esta además la clasificación más general de algoritmos.
  - Otros son el aprendizaje por refuerzo y los sistemas de recomendación.
- Hay que aprender las herramientas, pero *es muy importante saber cómo y cuándo usarlas*.
- Sea una máquina que debe hacer una tarea T, con un desempeño P y que la exponemos a experiencias (instancias) E de esa tarea T. Se dice que la computadora aprende si su desempeño P en la tarea T /aumenta proporcionalmente a la cantidad de experiencias E/.
- Otra definición de aprendizaje automático es la capacidad (de la computadora) de aprender a resolver problemas para los que no fue programada. ~

*** Reading: What is Machine Learning?

*** Video: Supervised Learning

- En el aprendizaje supervisado, le mostramos al programa ejemplos de entradas y sus correspondientes salidas/respuestas correctas. Ya sabemos cómo son las respuestas corectas; tenemos la idea de que hay una relación entre las entradas y las salidas. Dado un conjunto de entradas y salidas, intentamos obtener un modelo que permita predecir/inferir las salidas a nuevos datos de entrada.
- Los problemas de aprendizaje supervisado se clasifican en problemas de regresión y de clasificación:
  - Problema de *regresión* si el conjunto imagen es continuo. La salida es una variable numérica.
  - Problema de *clasificación* si el conjunto imagen es discreto. La salida es una variable categórica.
- Los algoritmos de Máquinas de Vector Soporte permiten /*infinitos*/ valores de entrada.

****** TODO Leer https://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression

****** TODO Leer https://datascience.stackexchange.com/questions/25298/how-to-know-when-to-treat-a-problem-as-a-classification-task-or-a-regression-tas

*** Video: Unsupervised Learning

- En el aprendizaje no supervisado, le damos datos al programa con la intención de encontrar estructuras subyacentes, patrones.
- Un ejemplo típico es el /clustering/ o agrupamiento de datos.
- En el ejemplo de sonido Cocktail Party, según [[https://www.coursera.org/learn/machine-learning/discussions/weeks/1/threads/hAp4LT1SEeaL_xIEq4QdBw][FAQ de la semana 1]], lo que usan es /Principal Component Analysis, PCA, a mathematical trick that takes two sets of correlated data, and returns two new sets of data that are not correlated./ No lo había visto así antes, creo...

** Model and cost function

Vemos la regresión lineal como primer algoritmo de aprendizaje supervisado.

*** Video: Model representation

Un poco de nomenclatura:

- $m$: cantidad de ejemplos de entrenamiento.
- $\vec{x}$: entradas / descriptores / /features/
- $\vec{y}$: salidas. $\hat{\vec{y}}$ son las salidas estimadas.
- $h_\theta$: función de hipótesis, de estimación. Tiene parámetros $\vec{\theta}$. Entonces tenemos que \( \hat{y}^{(i)} = h_\theta(x^{(i)}) = h(x,\theta) \)
- $x^{(i)}$: entrada $i$-ésima del vector de entradas, con índices empezando en 1.
  - $(x^{(i)},y^{(i)})$ es un ejemplo de entrenamiento.
- Para regresión lineal de una variable tenemos entonces 
\[ \hat{y}^{(i)} = h_\theta(x^{(i)}) = \theta_0 + \theta_1 * x^{(i)} \]

*** Reading: Model representation

- $X$: el espacio de los valores de entrada.
- $Y$: el espacio de los valores de salida.
- El objetivo del aprendizaje supervisado es encontrar una función $h: X \rightarrow Y$ que sea buena prediciendo salidas a partir de entradas.
 
*** Video: Cost function

Formalizamos el problema del aprendizaje como la minimización de una función de costo $J(\vec{\theta})$. La función de costo habitual y recomendada para problemas de regresión lineal es el *error cuadrático medio* ([[https://en.wikipedia.org/wiki/Mean_squared_error][/Mean Squared Error/]] o /Mean Squared Deviation/).

Para un predictor como lo es $h_\theta$, el MSE se define como
\[ MSE = \frac{1}{N} (\sum_{1}^{N}Y_i - \hat{Y}_i )^2\]

En nuestro caso vamos a definir a la función de costo para este problema de regresión lineal univariable como

\[ J(\theta_0 , \theta_1) = \frac{1}{2m} \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} )^2  \]
\[ J(\theta_0 , \theta_1) =  \frac{1}{2m} \sum_{i=1}^m( \theta_0 + \theta_1 * x^{(i)} - y^{(i)} )^2 \]

- El factor $1/2$ es para ahorrar cálculos, puesto que en redes neuronales al hacer /backpropagation/ o /gradient descent/ hay que derivar esta función de error y entonces con este $1/2$ simplificamos el $2$ de la derivada del cuadrado.

La optimización es entonces encontrar los parámetros $\theta$ que minimizan la función de costo:
\[ \underset{\theta_0 , \theta_1}{\text{min}}  J(\theta_0 , \theta_1)\]

*** Reading: Cost function

*** Video: Cost function intuition I

*** Reading: Cost function intuition I

*** Video: Cost function intuition II

*** Reading: Cost function intuition II

De [[https://es.wikipedia.org/wiki/Isol%C3%ADnea][isolíneas / curvas de nivel]].


** Parameter learning

*** Video: Gradient descent

El descenso por el gradiente es un algoritmo de optimización que vamos a usar (entre otras cosas) para minimizar la función de costo.

Hacer \[ \vec{\theta}[n+1] := \vec{\theta}[n] - \alpha \frac{\delta J(\vec{\theta})}{\delta\theta}  \]

Hasta que \[  \vec{\theta}[n+1] - \vec{\theta}[n] < \epsilon \]

- Nomenclatura: usamos $:=$ como operador de asignación.
- $\alpha$ es la tasa de aprendizaje o /learning rate/ del algoritmo.

Para calcular la derivada hacemos derivadas parciales. Actualizamos los parámetros simultáneamente en cada paso. Si actualizamos de a uno estamos haciendo otro algoritmo, que probablemente también converja pero es distinto.

*** Reading: Gradient descent

*** Video: Gradient descent intuition

- Si $\alpha$ es muy grande, el algoritmo puede oscilar o incluso diverger.
- Si $\alpha$ es muy chica, puede tardar mucho en converger.
- Con $\alpha$ fija, los "pasos" que da el algoritmo son cada vez más chicos a medida que la función de costo se aproxima a un mínimo local.

*** Reading: Gradient descent intuition

*** Video: Gradient descent for linear regression

Dice Andrew cerca del minuto 4:40:

#+begin_quote
But, it turns out that that the cost function for
linear regression is always going to be a bow shaped function like this.
The technical term for this is that this is called a convex function.
#+end_quote

¿Por qué?

- La función de costo $J(\vec{\theta})$ es el error cuadrático medio (MSE).
- El MSE es cuadrático respecto a los parámetros siempre y cuando estos sean lineales, de grado 1. *La función de hipótesis debe ser lineal respecto a los parámetros para que la función de costo sea cuadrática*.
  - Sea por ejemplo \[ h(x,y) =  a.x^2 + b.y^2 - c.x^2 y^2 \]. Esta función tiene más de un mínimo.

[[file:imgs/001-01-nolineal.gif]]

  - Su MSE quedaría algo como \[ x^4 + 2 x^2 y^2 - 2 x^4 y^2 + y^4 - 2 x^2 y^4 + x^4 y^4  \] (sólo [[https://www.wolframalpha.com/input/?i=%28x%5E2+%2B+y%5E2+-+x%5E2y%5E2%29%5E2][la elevé al cuadrado]])

[[file:imgs/001-02-nolineal-cuadrado.gif]]

-----------------

Hay otras formas de estimar los parámetros (regresores). Una de ellas es el método de los mínimos cuadrados ([[https://en.wikipedia.org/wiki/Ordinary_least_squares][/Ordinary Least Squares]]/). El descenso por el gradiente es más fácil de computar que OLS, en el caso de datasets grandes.

En realidad todo lo que vimos es descenso por el gradiente por lotes, o */batch gradient descent/*, que es cuando la función de costo se optimiza usando todas las entradas disponibles. Esto es costoso.



****** TODO Leer más de [[https://en.wikipedia.org/wiki/Linear_regression][regresión lineal]]



**** Regresión lineal



*** Reading: Gradient descent for linear regression

** Linear Algebra review

*** Video: Matrix vector multiplication

- Más adelante vamos a ver por qué es mejor vectorizar calculos en lugar de iterar.
- Hace un truco interesante que es incluir a la ordenada al origen dentro del vector de parámetros ---en realidad está bien, es un parámetro calculado---, y luego introduce una columna de \(1\)s en la matriz de entradas.
  - La alternativa es sumar la columna aparte. $A*X + B$

*** Video: Matrix matrix multiplication

- Acá hace el mismo truco pero para hacer varias predicciones a la vez: usa varios modelos y varias entradas.

*** Video: Inverse and transpose

Interesante:
#+BEGIN_QUOTE
But the intuition if you want is that you can think of matrices as not have an inverse that is somehow too close to zero in some sense.
#+END_QUOTE

- Las matrices que no tienen inversa son matrices /singulares/ o /degeneradas/.
  - Asumo que se refiere a matrices cuadradas, que podrían tener inversa.

* Semana 2

** Environment setup instructions

** Multivariate linear regression

*** Video: Multivariate linear regression

En la regresión lineal multivariable o regresión lineal múltiple, tenemos varios valores de entrada o descriptores. Para tener una notación más compacta y conveniente, vamos a definir:
- $\theta_0=1$ ;
- $n$ es la cantidad de entradas, descriptores;
- vamos a usar $\vec{\theta}$ con índice $0$;
- y $\vec{\theta}_j^{(i)}$ es el elemento j-ésimo del ejemplo i-ésimo.

Entonces $\vec{\theta}$ tiene $n+1$ elementos y  \[ \vec{\theta} = 1 + \theta_1 + \theta_2 + \dots + \theta_n  \]


Y luego \[ \vec{h_\theta}(\vec{x}) = \vec{\theta}^T \cdot \vec{x}  \]

- Intuición para el ejemplo de estimar el precio de un inmueble: $\theta_0$ es el precio base.

*** Reading: multiple features

*** Video: Gradient descent for multiple features

La regla de actualización era:

 \[ \vec{\theta}[n+1] := \vec{\theta}[n] - \alpha \frac{\delta J(\vec{\theta})}{\delta\theta}  \]

Y para cuando la función de costo es el error cuadrático medio (MSE), queda (para actualización con todos los $m$ ejemplos):

\[ \vec{\theta}_j[n+1] := \vec{\theta}[n] - \alpha \sum_{i=1}^{m} \left( ( \vec{\theta}^T \cdot \vec{x}^{(i)} - y^{(i)}  ) x_j^{(i)} \right) \]

- Puedo ver el factor de avance luego de $\alpha$ como el aporte al error medio que hizo el descriptor $x_j$ .
  - El producto vectorial y la resta son el error medio para ese vector de entrada.
  - El factor $x_j$ es el aporte de ese elemento, en esa dirección.
    - La dirección final es la suma vectorial de los elementos.

**** TODO EL ERROR ES MAYPR CUANDO HAY CORRELACIÓN ENTRE DESCRIPTORES Y PARÁMETROS.

*** Reading: Gradient descent for multiple features

*** Video: Gradient descent in practice I - Feature scaling

- Al parecer, el algoritmo de descenso por el gradiente converge *bastante más rápidamente* si los descriptores están en el mismo orden de magnitud.
  - Andrew propone que estén /más o menos/ en el rango $-3 < x_j < 3$ y duda si $-\frac{1}{3} < x < \frac{1}{3}$
- Para esto se suele normalizar cada descriptor respecto al rango de sí mismo en la muestra (los m ejemplos de entrada) o respecto a la desviación estándar. Esto se llama */feature scaling/*.
- Otra práctica habitual es centrar en cero los valores, para lo cual se resta la media de la muestra. Esto se llama */mean normalization/*.

**** Más de feature scaling y mean normalization

De la ecuación de actualización de los parámetros de la ecuación de hipótesis infiero que el vector se mueve _más rápidamente_ en dirección de los parámetros más grandes. Sin embargo en [[*Reading: Gradient descent in practice I - Feature scaling]] dice:

#+begin_quote
This is because θ will descend quickly on small ranges and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven.
#+end_quote

****** TODO Averiguar más de esto. ¿Por qué se hace? ¿Tienen que ser de la misma magnitud o ser chicos?

*** Reading: Gradient descent in practice I - Feature scaling


*** Video: Gradient descent in practice II - Learning rate

- Si la función de costo $J(\vec{\theta})$ diverge u oscila, entonces mi tasa de aprendizaje $\alpha$ es muy grande. Si es muy chica, converge lentamente.
- Puedo verlo graficando la función de costo.
- Elegir el valor de $\alpha$ es, a priori, por prueba y error. */¿Habrá heurísticas para determinar un buen valor inicial?/*
- La condición de convergencia también suele depender del problema. Andrew habla de valores absolutos... */¿por qué no usar un $\epsilon$ relativo?/*

*** Reading: Gradient descent in practice II - Learning rate


*** Video: Features and polynomial regression

*** Reading: Features and polynomial regression

- La regresión lineal es ajustar un modelo lineal, de grado 1, una combinación lineal entre las entradas y parámetros.
- Podemos ajustar modelos no lineales como hipótesis si codificamos estas no linealidades dentro de los descriptores. Por ejemplo, para el caso de la estimación de precios de casas, un posible descriptor podría ser el cuadrado del área, y ahí estamos incluyendo algo cuadrático en el modelo.
- Al incluir las no linealidades en los descriptores, pero todavía usando los parámetros como multiplicadores de orden 1, podemos seguir usando el descenso por el gradiente para optimizar.
- Andrew habla también de usar relaciones entre entradas básicas para construir otras entradas. Por ejemplo, el producto de dos descriptores hace un nuevo descriptor que codifica otra relación.

** Computing parameters analitically

*** Video: Normal equation

- Otra forma de optimizar la regresión lineal es resolverla analíticamente con el método de los [[https://en.wikipedia.org/wiki/Least_squares][mínimos cuadrados]] [[https://en.wikipedia.org/wiki/Linear_least_squares][lineales]] / ecuación normal. Esto da la solución óptima (que existe porque hemos dicho que para regresión lineal es un espacio de búsqueda cónvexo con un solo mínimo).

\[  \vec{\theta} = ( X^T \times X )^{-1} \times X^T \times \vec{y}   \]

\[ X = \left[  x^{(i)}  \right]  \]

- La complejidad de invertir una matriz es $O(n^3)$ y esto se pone lento para $n > 10^5$. La complejidad del descenso por el gradiente, en cambio, es de $O(k \cdot n^2)$.

- \(( X^T \times X )^{-1} \times X^T = X^{+}\) es la _[[https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse][pseudoinversa]]_ de $X$, y el método de mínimos cuadrados no es más que una solución (óptima en el sentido del error cuadrático) de un sistema de ecuaciones sobredeterminado.

  - La pseudoinversa se puede calcular con /Singular Value Decomposition/ o Descomposición QR, por ejemplo.

  - La regresión por mínimos cuadrados asume muchas cosas que no necesariamente siempre se cumplen. Ver la [[https://en.wikipedia.org/wiki/Robust_regression][regresión robusta]] como alternativa.

*** Reading: Normal equation

*** Video: Normal equation noninvertibility

Si $( X^T \times X )$ no es invertible, entonces puede haber 2 problemas:

1. El sistema esta subdeterminado. Faltan ejemplos, $m < n$ / tenemos muchos descriptores.
   - Después vamos a ver que se soluciona con /regularización/.
2. Algunos descriptores están muy correlacionados / son linealmente dependientes.

Si no es invertible naturalmente (es singular o degenerada) igual se puede invertir con la pseudoinversa. Igual esto no sería problema si hubiésemos usado la pseudoinversa desde un principio en lugar de estar haciéndolo manualmente. Y, nuevamente, seguro hay métodos más robustos (aunque no hay que dejar de hacer análisis de la información con la que contamos).

*** Reading: Normal equation noninvertibility


** Submitting programming assignments

** Review

** Octave/Matlab tutorial

** Review

* Semana 3

* Semana 4
