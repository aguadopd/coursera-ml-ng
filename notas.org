#+author: Pablo Aguado
#+title: Notas del curso Machine Learning de Andrew Ng en Coursera
#+description: Mis notas.

#+STARTUP: indent content align entitiespretty


* Info

- https://www.coursera.org/learn/machine-learning
- [[https://www.coursera.org/learn/machine-learning/discussions/all/threads/v2YppY8FEeWIeBJxvl1elQ][Important notes for new ML students]]
  - Hay más /test cases/ en los Recursos del curso.
  - *Hay que usar Octave > 4.0.0*
  - [[https://learner.coursera.help/hc/en-us/articles/209818863-Coursera-Honor-Code][Cousera Honor Code]]

* Ideas

Ideas mías a lo largo del curso.

1. Probar [[https://github.com/google-research/google-research/blob/master/automl_zero/README.md][AutoML-Zero]].
2. Buscar clusters en espacios transformados y muy transformados. Ej: Fourier, Fourier de Fourier, Cepstrum...

** Enlaces

1. http://www.deeplearningbook.org/
2. http://ufldl.stanford.edu/tutorial/  Deep Learning Tutorial
3. https://developers.google.com/machine-learning/crash-course
4. https://deeplearning.mit.edu/

* Semana 1

Intro, regresión lineal, repaso de Álgebra.


- [[https://www.coursera.org/learn/machine-learning/discussions/weeks/1/threads/hAp4LT1SEeaL_xIEq4QdBw][FAQ de la semana 1]]

** Introduction
*** Video: Welcome

*** Video: What is Machine Learning

- Los algoritmos más importantes son el aprendizaje supervisado y el aprendizaje no supervisado. Es esta además la clasificación más general de algoritmos.
  - Otros son el aprendizaje por refuerzo y los sistemas de recomendación.
- Hay que aprender las herramientas, pero *es muy importante saber cómo y cuándo usarlas*.
- Sea una máquina que debe hacer una tarea T, con un desempeño P y que la exponemos a experiencias (instancias) E de esa tarea T. Se dice que la computadora aprende si su desempeño P en la tarea T /aumenta proporcionalmente a la cantidad de experiencias E/.
- Otra definición de aprendizaje automático es la capacidad (de la computadora) de aprender a resolver problemas para los que no fue programada. ~

*** Reading: What is Machine Learning?

*** Video: Supervised Learning

- En el aprendizaje supervisado, le mostramos al programa ejemplos de entradas y sus correspondientes salidas/respuestas correctas. Ya sabemos cómo son las respuestas corectas; tenemos la idea de que hay una relación entre las entradas y las salidas. Dado un conjunto de entradas y salidas, intentamos obtener un modelo que permita predecir/inferir las salidas a nuevos datos de entrada.
- Los problemas de aprendizaje supervisado se clasifican en problemas de regresión y de clasificación:
  - Problema de *regresión* si el conjunto imagen es continuo. La salida es una variable numérica.
  - Problema de *clasificación* si el conjunto imagen es discreto. La salida es una variable categórica.
- Los algoritmos de Máquinas de Vector Soporte permiten /*infinitos*/ valores de entrada.

****** TODO Leer https://stats.stackexchange.com/questions/22381/why-not-approach-classification-through-regression

****** TODO Leer https://datascience.stackexchange.com/questions/25298/how-to-know-when-to-treat-a-problem-as-a-classification-task-or-a-regression-tas

*** Video: Unsupervised Learning

- En el aprendizaje no supervisado, le damos datos al programa con la intención de encontrar estructuras subyacentes, patrones.
- Un ejemplo típico es el /clustering/ o agrupamiento de datos.
- En el ejemplo de sonido Cocktail Party, según [[https://www.coursera.org/learn/machine-learning/discussions/weeks/1/threads/hAp4LT1SEeaL_xIEq4QdBw][FAQ de la semana 1]], lo que usan es /Principal Component Analysis, PCA, a mathematical trick that takes two sets of correlated data, and returns two new sets of data that are not correlated./ No lo había visto así antes, creo...

** Model and cost function

Vemos la regresión lineal como primer algoritmo de aprendizaje supervisado.

*** Video: Model representation

Un poco de nomenclatura:

- $m$: cantidad de ejemplos de entrenamiento.
- $\vec{x}$: entradas / descriptores / /features/
- $\vec{y}$: salidas. $\hat{\vec{y}}$ son las salidas estimadas.
- $h_\theta$: función de hipótesis, de estimación. Tiene parámetros $\vec{\theta}$. Entonces tenemos que \( \hat{y}^{(i)} = h_\theta(x^{(i)}) = h(x,\theta) \)
- $x^{(i)}$: entrada $i$-ésima del vector de entradas, con índices empezando en 1.
  - $(x^{(i)},y^{(i)})$ es un ejemplo de entrenamiento.
- Para regresión lineal de una variable tenemos entonces 
\[ \hat{y}^{(i)} = h_\theta(x^{(i)}) = \theta_0 + \theta_1 * x^{(i)} \]

*** Reading: Model representation

- $X$: el espacio de los valores de entrada.
- $Y$: el espacio de los valores de salida.
- El objetivo del aprendizaje supervisado es encontrar una función $h: X \rightarrow Y$ que sea buena prediciendo salidas a partir de entradas.
 
*** Video: Cost function

Formalizamos el problema del aprendizaje como la minimización de una función de costo $J(\vec{\theta})$. La función de costo habitual y recomendada para problemas de regresión lineal es el *error cuadrático medio* ([[https://en.wikipedia.org/wiki/Mean_squared_error][/Mean Squared Error/]] o /Mean Squared Deviation/).

Para un predictor como lo es $h_\theta$, el MSE se define como
\[ MSE = \frac{1}{N} (\sum_{1}^{N}Y_i - \hat{Y}_i )^2\]

En nuestro caso vamos a definir a la función de costo para este problema de regresión lineal univariable como

\[ J(\theta_0 , \theta_1) = \frac{1}{2m} \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} )^2  \]
\[ J(\theta_0 , \theta_1) =  \frac{1}{2m} \sum_{i=1}^m( \theta_0 + \theta_1 * x^{(i)} - y^{(i)} )^2 \]

- El factor $1/2$ es para ahorrar cálculos, puesto que en redes neuronales al hacer /backpropagation/ o /gradient descent/ hay que derivar esta función de error y entonces con este $1/2$ simplificamos el $2$ de la derivada del cuadrado.

La optimización es entonces encontrar los parámetros $\theta$ que minimizan la función de costo:
\[ \underset{\theta_0 , \theta_1}{\text{min}}  J(\theta_0 , \theta_1)\]

------

/En las notas del curso encontramos la forma matricial, que luego usamos para hacer descenso por el gradiente de forma matricial. Lo pongo acá por completitud/.

MSE: \[ J(\theta) = \frac{1}{2m} (X\times\theta-Y)^T(X\times\theta-Y)  \]

El producto implica la sumatoria y el cuadrado elemento a elemento.

------

*** Reading: Cost function

*** Video: Cost function intuition I

*** Reading: Cost function intuition I

*** Video: Cost function intuition II

*** Reading: Cost function intuition II

De [[https://es.wikipedia.org/wiki/Isol%C3%ADnea][isolíneas / curvas de nivel]].


** Parameter learning

*** Video: Gradient descent

El descenso por el gradiente es un algoritmo de optimización que vamos a usar (entre otras cosas) para minimizar la función de costo.

Hacer \[ \vec{\theta}[n+1] := \vec{\theta}[n] - \alpha \frac{\partial J(\vec{\theta})}{\partial\theta}  \]

(expresado de otra manera)

\[ {\theta}_j[n+1] := {\theta}_j[n] - \alpha \frac{\partial J(\vec{\theta})}{\partial\theta}  \]

Hasta la convergencia de \(\vec{\theta}\), equivalente a la convergencia de \(J(\vec{\theta})\):

\[  \vec{\theta}[n] - \vec{\theta}[n-1] < \vec{\epsilon} \]
\[ J(\vec{\theta}[n]) - J(\vec{\theta}[n-1])  < \epsilon  \]

- Nomenclatura: usamos $:=$ como operador de asignación.
- $\alpha$ es la tasa de aprendizaje o /learning rate/ del algoritmo.

Para calcular la derivada hacemos derivadas parciales. Actualizamos los parámetros simultáneamente en cada paso. Si actualizamos de a uno y recalculamos estamos haciendo otro algoritmo, que probablemente también converja pero es distinto.

Cuando la función de costo es el error cuadrático medio (/MSE/), la fórmula de actualización queda:

\[ \theta_j[n+1] := {\theta}_j[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)}  \]

- El primer termino de la sumatoria es la magnitud y dirección del error.
- El segundo término de la sumatoria es la sensibilidad de J respecto al parámetro, y resulta ser igual a la magnitud del descriptor asociado a ese parámetro.

-----

- [[https://www.youtube.com/watch?v=WnqQrPNYz5Q][Un video de /gradient descent/ sugerido en las notas del curso]].

*** Reading: Gradient descent

*** Video: Gradient descent intuition

- Si $\alpha$ es muy grande, el algoritmo puede oscilar o incluso diverger.
- Si $\alpha$ es muy chica, puede tardar mucho en converger.
- Con $\alpha$ fija, los "pasos" que da el algoritmo son cada vez más chicos a medida que la función de costo se aproxima a un mínimo local.

*** Reading: Gradient descent intuition

*** Video: Gradient descent for linear regression

Dice Andrew cerca del minuto 4:40:

#+begin_quote
But, it turns out that that the cost function for
linear regression is always going to be a bow shaped function like this.
The technical term for this is that this is called a convex function.
#+end_quote

¿Por qué?

- La función de costo $J(\vec{\theta})$ es el error cuadrático medio (MSE).
- El MSE es cuadrático respecto a los parámetros siempre y cuando estos sean lineales, de grado 1. *La función de hipótesis debe ser lineal respecto a los parámetros para que la función de costo sea cuadrática*.
  - Sea por ejemplo \[ h(x,y) =  a.x^2 + b.y^2 - c.x^2 y^2 \]. Esta función tiene más de un mínimo.

[[file:imgs/001-01-nolineal.gif]]

  - Su MSE quedaría algo como \[ x^4 + 2 x^2 y^2 - 2 x^4 y^2 + y^4 - 2 x^2 y^4 + x^4 y^4  \] (sólo [[https://www.wolframalpha.com/input/?i=%28x%5E2+%2B+y%5E2+-+x%5E2y%5E2%29%5E2][la elevé al cuadrado]])

[[file:imgs/001-02-nolineal-cuadrado.gif]]

-----------------

Hay otras formas de estimar los parámetros (regresores). Una de ellas es el método de los mínimos cuadrados ([[https://en.wikipedia.org/wiki/Ordinary_least_squares][/Ordinary Least Squares]]/). El descenso por el gradiente es más fácil de computar que OLS, en el caso de datasets grandes.

En realidad todo lo que vimos es descenso por el gradiente por lotes, o */batch gradient descent/*, que es cuando la función de costo se optimiza usando todas las entradas disponibles. Esto es costoso.



****** TODO Leer más de [[https://en.wikipedia.org/wiki/Linear_regression][regresión lineal]]



**** Regresión lineal



*** Reading: Gradient descent for linear regression

** Linear Algebra review

*** Video: Matrix vector multiplication

- Más adelante vamos a ver por qué es mejor vectorizar calculos en lugar de iterar.
- Hace un truco interesante que es incluir a la ordenada al origen dentro del vector de parámetros ---en realidad está bien, es un parámetr calculado---, y luego introduce una columna de \(1\)s en la matriz de entradas.
  - La alternativa es sumar la columna aparte. $A*X + B$

*** Video: Matrix matrix multiplication

- Acá hace el mismo truco pero para hacer varias predicciones a la vez: usa varios modelos y varias entradas.

*** Video: Inverse and transpose

Interesante:
#+BEGIN_QUOTE
But the intuition if you want is that you can think of matrices as not have an inverse that is somehow too close to zero in some sense.
#+END_QUOTE

- Las matrices que no tienen inversa son matrices /singulares/ o /degeneradas/.
  - Asumo que se refiere a matrices cuadradas, que podrían tener inversa.

* Semana 2

** Environment setup instructions

** Multivariate linear regression

*** Video: Multivariate linear regression

En la regresión lineal multivariable o regresión lineal múltiple, tenemos varios valores de entrada o descriptores. Para tener una notación más compacta y conveniente, vamos a definir:
- $\theta_0=1$ ;
- $n$ es la cantidad de entradas, descriptores;
- vamos a usar $\vec{\theta}$ con índice $0$;
- y $\vec{\theta}_j^{(i)}$ es el elemento j-ésimo del ejemplo i-ésimo.

Entonces $\vec{\theta}$ tiene $n+1$ elementos y  \[ \vec{\theta} = 1 + \theta_1 + \theta_2 + \dots + \theta_n  \]


Y luego \[ \vec{h_\theta}(\vec{x}) = \vec{\theta}^T \cdot \vec{x}  = \vec{x}^T \cdot \vec{\theta}  \]

- Intuición para el ejemplo de estimar el precio de un inmueble: $\theta_0$ es el precio base.

------

/En [[*Video: Normal equation]] se introduce notación matricial que luego en el ejercicio 1 usamos para expresar todo de forma vectorizada. Dejo todo acá para más completitud/.

\[ \hat{Y}(\theta,X) = X \theta  ]\

------

*** Reading: multiple features

*** Video: Gradient descent for multiple features

La regla de actualización era:

 \[ \vec{\theta}[n+1] := \vec{\theta}[n] - \alpha \frac{\partial J(\vec{\theta})}{\partial\theta}  \]

Y para cuando la función de costo es el error cuadrático medio (MSE), queda (para actualización con *todos los $m$ ejemplos*):

\[ \theta_j[n+1] := {\theta}_j[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)}  \]

- Puedo ver el factor de avance luego de $\alpha$ como el aporte al error medio que hizo el descriptor $x_j$ .
  - El producto vectorial y la resta son el error medio para ese vector de entrada.
  - El factor $x_j$ es el aporte de ese elemento, en esa dirección.
    - La dirección final es la suma vectorial de los elementos.

-------

/La versión vectorizada/matricial del algoritmo está en las notas del curso y después la usamos en el ejercicio de programación 1. La dejo acá por completitud/.

\[ \theta_{n \times 1}[i+1] = \theta_{n \times 1}[i] - \frac{\alpha}{m} X_{m \times n}^T (X_{m \times n} \theta_{n \times 1} - Y_{m \times 1} )_{m \times 1} \]
\[ \theta_{}[i+1] = \theta[i] - \frac{\alpha}{m} X^T (X \theta - Y) \]

-----------

**** TODO EL ERROR ES MAYPR CUANDO HAY CORRELACIÓN ENTRE DESCRIPTORES Y PARÁMETROS.

*** Reading: Gradient descent for multiple features

*** Video: Gradient descent in practice I - Feature scaling

- Al parecer, el algoritmo de descenso por el gradiente converge *bastante más rápidamente* si los descriptores están en el mismo orden de magnitud.
  - Andrew propone que estén /más o menos/ en el rango $-3 < x_j < 3$ y duda si $-\frac{1}{3} < x < \frac{1}{3}$
- Para esto se suele normalizar cada descriptor respecto al rango de sí mismo en la muestra (los m ejemplos de entrada) o respecto a la desviación estándar. Esto se llama */feature scaling/*.
- Otra práctica habitual es centrar en cero los valores, para lo cual se resta la media de la muestra. Esto se llama */mean normalization/*.

**** Más de feature scaling y mean normalization

De la ecuación de actualización de los parámetros de la ecuación de hipótesis
infiero que el vector se mueve _más rápidamente_ en dirección de los parámetros
más grandes. Sin embargo en [[*Reading: Gradient descent in practice I - Feature scaling]] dice:

#+begin_quote
This is because θ will descend quickly on small ranges and slowly on large ranges, and so will oscillate inefficiently down to the optimum when the variables are very uneven.
#+end_quote

****** DONE Averiguar más de esto. ¿Por qué se hace? ¿Tienen que ser de la misma magnitud o ser chicos?
CLOSED: [2020-04-18 sáb 02:46]

- Ver https://www.robertoreif.com/blog/2017/12/21/importance-of-feature-scaling-in-data-modeling-part-2
- Ver https://math.stackexchange.com/questions/2341704/feature-scalings-effect-on-gradient-descent

Estaba entendiendo mal las curvas de nivel. El eje corto de las elipses es el asociado a los descriptores más grandes, con más rango. Son curvas de nivel de $J(\theta)$, no de $J(x)$.  Ahora si estoy de acuerdo.

En regresión lineal (quizás puedo generalizarlo a cualquiera) *los parámetros tienen rangos "inversos" a los de los descriptores que multiplican*. Si un descriptor tiene un rango grande, entonces su parámetro asociado va a tener un rango chico.

_Se podría solucionar también con learning rates diferenciados: más grandes para los descriptores de más rango, más chicos para los de menos rango._

¡Lo que dice en [[*Reading: Gradient descent in practice I - Feature scaling]] está mal expresado entonces!

****** TODO Corregir https://math.stackexchange.com/questions/2341704/feature-scalings-effect-on-gradient-descent

*** Reading: Gradient descent in practice I - Feature scaling


*** Video: Gradient descent in practice II - Learning rate

- Si la función de costo $J(\vec{\theta})$ diverge u oscila, entonces mi tasa de aprendizaje $\alpha$ es muy grande. Si es muy chica, converge lentamente.
- Puedo verlo graficando la función de costo.
- Elegir el valor de $\alpha$ es, a priori, por prueba y error. */¿Habrá heurísticas para determinar un buen valor inicial?/*
- La condición de convergencia también suele depender del problema. Andrew habla de valores absolutos... */¿por qué no usar un $\epsilon$ relativo?/*

*** Reading: Gradient descent in practice II - Learning rate


*** Video: Features and polynomial regression

*** Reading: Features and polynomial regression

- La regresión lineal es ajustar un modelo lineal, de grado 1, una combinación lineal entre las entradas y parámetros.
- Podemos ajustar modelos no lineales como hipótesis si codificamos estas no linealidades dentro de los descriptores. Por ejemplo, para el caso de la estimación de precios de casas, un posible descriptor podría ser el cuadrado del área, y ahí estamos incluyendo algo cuadrático en el modelo.
- Al incluir las no linealidades en los descriptores, pero todavía usando los parámetros como multiplicadores de orden 1, podemos seguir usando el descenso por el gradiente para optimizar.
- Andrew habla también de usar relaciones entre entradas básicas para construir otras entradas. Por ejemplo, el producto de dos descriptores hace un nuevo descriptor que codifica otra relación.

** Computing parameters analitically

*** Video: Normal equation

- Otra forma de optimizar la regresión lineal es resolverla analíticamente con el método de los [[https://en.wikipedia.org/wiki/Least_squares][mínimos cuadrados]] [[https://en.wikipedia.org/wiki/Linear_least_squares][lineales]] / ecuación normal. Esto da la solución óptima (que existe porque hemos dicho que para regresión lineal es un espacio de búsqueda cónvexo con un solo mínimo).

\[  \vec{\theta} = ( X^T \times X )^{-1} \times X^T \times \vec{y}   \]

\[ X = \left[  x^{(i)}  \right]  \]

- A $X$ la llamamos */matriz de diseño/*. Cada fila es un ejemplo, y tiene tamaño $m \times n+1 $

- La complejidad de invertir una matriz es $O(n^3)$ y esto se pone lento para $n > 10^5$. La complejidad del descenso por el gradiente, en cambio, es de $O(k \cdot n^2)$.

- \(( X^T \times X )^{-1} \times X^T = X^{+}\) es la _[[https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse][pseudoinversa]]_ de $X$, y el método de mínimos cuadrados no es más que una solución (óptima en el sentido del error cuadrático) de un sistema de ecuaciones sobredeterminado.

  - La pseudoinversa se puede calcular con /Singular Value Decomposition/ o Descomposición QR, por ejemplo.

  - La regresión por mínimos cuadrados asume muchas cosas que no necesariamente siempre se cumplen. Ver la [[https://en.wikipedia.org/wiki/Robust_regression][regresión robusta]] como alternativa.

*** Reading: Normal equation

*** Video: Normal equation noninvertibility

Si $( X^T \times X )$ no es invertible, entonces puede haber 2 problemas:

1. El sistema esta subdeterminado. Faltan ejemplos, $m < n$ / tenemos muchos descriptores.
   - Después vamos a ver que se soluciona con /regularización/.
2. Algunos descriptores están muy correlacionados / son linealmente dependientes.

Si no es invertible naturalmente (es singular o degenerada) igual se puede invertir con la pseudoinversa. Igual esto no sería problema si hubiésemos usado la pseudoinversa desde un principio en lugar de estar haciéndolo manualmente. Y, nuevamente, seguro hay métodos más robustos (aunque no hay que dejar de hacer análisis de la información con la que contamos).

*** Reading: Normal equation noninvertibility


** Submitting programming assignments

** Review

** Octave/Matlab tutorial

#+BEGIN_SRC octave
  % Para ver una matriz/vector como píxeles con color
  A = magic(9)
  figure
  imagesc(A)
  colorbar
  colormap gray
#+END_SRC


** Review

*** Programming assignment 1: linear regression

- Mi gradient descent convergía pero no al mismo resultado exacto, y más rápida o lentamente. Me faltaba el factor $1/m$.
- Armé una versión vectorizada del gradient descent pero es distinta a la propuesta:

La mía:

- usé $n$ como la longitud de $\theta$, incluyendo los \(1\)s.

#+begin_src octave
  M = length(y); % number of training examples
  N = length(theta);
  error = (X * theta) - y;  % Mx1
  % ponderated_error = repmat(error, [1, N]) .* X;  % MxN
  % ponderated_error = error * ones(1,n) * X  % MxN, equivale al broadcasting
  ponderated_error = error .* X;  % Broadcasting. MxN
  % gradient = sum(ponderated_error,1);  % 1xN
  gradient = ones(1,M) * ponderated_error;  % 1xN, equivalente a la sumatoria
  theta = theta - (alpha/M) * gradient';  % Nx1
#+end_src

\[ \theta_{n \times 1}[i+1] = \theta_{n \times 1}[i] - \frac{\alpha}{m} \left[ 1_{1 \times m} \left( X_{m \times n} \theta_{n \times 1} - Y_{m \times 1} \right)_{m \times 1} 1_{1 \times n} X_{m \times n} \right]^T  \]

La original es más compacta:

\[ \theta_{n \times 1}[i+1] = \theta_{n \times 1}[i] - \frac{\alpha}{m} X_{m \times n}^T (X_{m \times n} \theta_{n \times 1} - Y_{m \times 1} )_{m \times 1} \]

* Semana 3

** Classification and representation

*** Classification

Vamos a ver la *regresión logística* que es un algoritmo de clasificación (aunque su nombre diga /regresión/).

La regresión lineal no es un buen método para la clasificación en variables discretas. Acá necesitamos algo más no lineal. Una opción es usar regresión lineal + un umbral arbitrario de separación, pero aún no es suficiente.

Vamos a ver clasificación binaria. Definimos como $0$ y $1$ a las clases. También usamos *etiqueta* para denominar a la salida $h_\theta(x)$.

*** Hypothesis representation

En clasificación binaria, los resultados observados sólo pueden tomar los valores $0$ y $1$, y por tanto nuestra función de hipótesis debería también sólo tomar esos valores.

Para empezar elegimos una función que esté acotada a ese rango. Una opción es la *función logística* o *sigmoidea*:

\[ h(z) = \frac{1}{1+e^z} \]

\[ h(\theta,x) = h_\theta(x) = \frac{1}{1+e^{\theta^T  x}}\]

- Mapea los reales al intervalo $[0, 1]$.

Podemos interpretar los resultados como la probabilidad de que la hipótesis tome un valor, dada determinada entrada.

- La suma de las probabilidades debe ser $1$.


**** La función logística o sigmoidea

- Se parece a la función cumulativa o función de distribución acumulada de una distribución normal/gaussiana.
  - Pero esta tiene una función explícita, mientras que la FDA de la gaussiana no tiene forma cerrada.
  - La función de densidad de probabilidad asociada "Se parece a la distribución normal en su forma, pero tiene colas más pesadas (y, por lo tanto, menor curtosis)". [[https://es.wikipedia.org/wiki/Distribuci%C3%B3n_log%C3%ADstica][Wikipedia: Distribución logística]]
- Puedo pensar que la FDP de la distribución logística me indica la cantidad de información que me da el valor de un descriptor. En el pico es donde más aporta; luego mientras más me alejo del centro, más claro es que es de una clase o de la otra.
- Es una aproximación suave de la función escalón.

[[file:imgs/002-320px-Logistic-curve.svg.png]]

\[ f(x) = \frac{L}{1+e^{-k(x-x_0)}}  \]

- $L$ es el valor máximo.
- $k$ es la tasa de crecimiento o pendiente de la curva.
- $x_0$ es el centro

*** Decision boundary

La clasificación es discreta; para hacerla discreta necesitamos agregar un umbral a nuestra función de hipótesis. /No entiendo por qué pone el umbral como si fuese una cosa aparte de la función de hipótesis/. Entonces, para la regresión logística hacemos:

\[ y = 0 \quad \text{si} \quad h(z) = h(z(\theta, x)) = h(\theta^T x) \lt 0,5 \]
\[ y = 0 \quad \text{si} \quad h(z) = h(z(\theta, x)) = h(\theta^T x) \geq 0,5 \]

Lo que equivale a

\[ y = 0 \quad \text{si} \quad  \theta^T x < 0,5 \]
\[ y = 1 \quad \text{si} \quad \theta^T x \ge 0,5 \]

La función de entrada a la sigmoidea, $z(\theta,x)$ define el umbral de decisión. Al igual que vimos para regresión lineal, esta función no tiene por qué ser lineal con respecto a los descriptores (/¿mas sí lineal respecto a los parámetros?/), y es la que va a separar las clases en su espacio. Por ejemplo, para dos variables podría ser un elipsoide: \( z(\theta,x) = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \theta_3 x_1^2 + \theta_4 x_2^2 \).

** Logistic regression model

*** Cost function

Sea la función de costo $J$ la media de una función de error:

\[ J(\theta) = \frac{1}{m} \sum_1^m  error(\hat{y}, y) \]

Si usamos el error cuadrático medio como función de error para optimizar con el descenso por el gradiente, vamos a tener que derivar una función no lineal. Esto es porque la función logística/sigmoidea $h(z)$ no es lineal con respecto a los parámetros \theta, y por tanto el error cuadrático medio no es una función convexa; esto implica que tiene (¿o puede tener?) más de un mínimo.

Lo que hacemos entonces es proponer otra función de error que sea convexa y diferenciable. Por supuesto, tiene que penalizar las predicciones/hipótesis erróneas. La que se propone es

\[ error(h_\theta(x)) = error(h(\theta,x) = \quad -\log(h_\theta(x)) \quad \text{si} \quad y = 1   \]
\[ error(h_\theta(x)) = error(h(\theta,x) = \quad -\log(1-h_\theta(x)) \quad \text{si} \quad y = 0   \]

#+begin_src octave :exports none
  figure(1, "visible", "off");
  hold on;
  grid
  fplot("-log(x)", [0, 1, 0, 5], 'lineWidth', 4)
  set(gca, "linewidth", 4, "fontsize", 18)
  title('error(h( \theta ,x) = -log(h_\theta(x))')
  legend off;
  % l = legend;
  % set(l, "fontsize", 14, "location","east")
  print("-S300,300", "./imgs/003-01-logcost1.png")
  ans = "[[file:./imgs/003-01-logcost1.png]]"
#+end_src

#+RESULTS:
: [[file:./imgs/003-01-logcost1.png]]

[[file:./imgs/003-01-logcost1.png]]



#+begin_src octave :exports none
  figure(1, "visible", "off");
  hold on;
  grid
  fplot("-log(1-x)", [0, 1, 0, 5], 'lineWidth', 4)
  set(gca, "linewidth", 4, "fontsize", 18)
  title('error(h( \theta ,x) = -log(1-h_\theta(x))')
  legend off;
  % l = legend;
  % set(l, "fontsize", 14, "location","east")
  print("-S300,300", "./imgs/003-02-logcost2.png")
  ans = "[[file:./imgs/003-02-logcost2.png]]"
#+end_src

#+RESULTS:
: [[file:./imgs/003-02-logcost2.png]]

[[file:./imgs/003-02-logcost2.png]]

- Nótese que tienden a infinito en $0$ y $1$ respectivamente.
- Usamos el *logaritmo natural*, base $e$.

------

En la sección siguiente Andrew dice que esta función de costo (en realidad su forma simplificada) se puede derivar estadísticamente a partir del principio de estimación de máxima verisimilitud.

*** Simplified cost function and gradient descent

**** Forma simplificada

Teníamos a la función de error para la regresión logística como:

\[ error(h_\theta(x)) = error(h(\theta,x)) = \quad -\log(h_\theta(x)) \quad \text{si} \quad y = 1   \]
\[ error(h_\theta(x)) = error(h(\theta,x)) = \quad -\log(1-h_\theta(x)) \quad \text{si} \quad y = 0   \]

La forma simplificada es:

\[ error(h(\theta,x)) = y (-\log(h_\theta(x))) + (1-y) (-\log(1-h_\theta(x)))   \]

\[ error(h(\theta,x)) = -y \log(\hat{y}) - (1-y) \log(\hat{y})  \]

Esta función es convexa (si $h$ es la sigmoidea, al menos).

Luego la función de costo queda:

\[  J(h_\theta(x)) = J(h(\theta,x)) =  \frac{1}{m} \sum_{i=1}^m \left[ -y^{(i)} \log(h_\theta(x^{(i)})) - (1-y^{(i)}) \log(1-h_\theta(x^{(i)}))  \right]  \]

La forma vectorizada/matricial es:

\[ J(h(\theta,X)) = \frac{1}{m} \left[ - Y^T \log(h(X\theta)) - (1-Y)^T \log(1-h(X\theta)) \right]  \]

**** Descenso por el gradiente

Resulta que la derivada $\delta J(\theta,x)/\delta \theta$, es la misma que la que obtuvimos usando el error cuadrático medio (/MSE/) como función de costo para regresión lineal, y entonces la formula de actualización de parámetros es la misma:

\[ \theta_j[n+1] := {\theta}_j[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)}  \]

En forma vectorizada/matricial:

\[ \theta_{}[i+1] = \theta[i] - \frac{\alpha}{m} X^T (h(X \theta) - Y) \]

*** Advanced optimization

Hay algoritmos generales de optimización mejores (pero más complejos) que el descenso por el gradiente. Andrew nombra:
  - [[https://en.wikipedia.org/wiki/Conjugate_gradient_method][Gradientes conjugados]]
  - BFGS ([[https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm][/Broyden–Fletcher–Goldfarb–Shanno algorithm/]])
  - L-BFGS ([[https://en.wikipedia.org/wiki/Limited-memory_BFGS][/Limited memory BFGS/]])

En Octave tenemos la función ~fminunc~ (de /function minimize unconstrained/) que nos permite optimizar usando una función de costo arbitraria. Le tenemos que proveer esa función de costo, que calcula la función de costo y el gradiente en cada iteración. En el ejemplo de Andrew, la función de costo calcula el gradiente de forma analítica, pero asumo que podrías también tener una memoria y usar diferencias.

** Multiclass classification

*** Multiclass classification: one vs all

Si tenemos $n$ salidas discretas posibles, podemos modelar el problema con $n$ clasificadores binarios, que toman una salida como caso positivo y el resto como negativo.

Una vez que clasificamos con todos los clasificadores, elegimos la salida definitiva como aquella que haya tenido la mayor confianza; y entonces tenemos que ver la probabilidad predicha antes de discretizarla.

Nótese que esto también se cumple en los binarios cuando $n=2$: podemos verlo como que ambos clasificadores definen la misma frontera de decisión.

** Solving the problem of overfitting

*** The problem of overfitting

Empezamos a evaluar la bondad de ajuste de nuestros modelos.

- Un modelo subajustado (/underfitted/) o de alto sesgo (/high bias/) tiene mucho error para los datos con los que se entrenó, y por ende muy probablemente tenga mucho error con entradas nuevas. El modelo no captura las características del espacio del problema.
  - El sesgo se asocia con prejuicio. El modelo prejuzga incorrectamente cómo deberían ser las entradas.
- Un modelo sobreajustado (/overfitted/) predice /demasiado/ correctamente los datos con los que se ajustó, pero no predice correctamente entradas que sean un poco distintas; *no generaliza*. También se habla de que es un modelo con alta varianza (/high variance/), porque el espacio de funciones de hipótesis (de la complejidad propuesta) que predicen bien es muy grande; hay muchos grados de libertad.

En los ejemplos mostrados, el ajuste se incrementa con el grado de las funciones de hipótesis, para regresión lineal. Entonces complejizar las funciones de hipótesis implica agregar más descriptores ---reales o sintéticos---.

**** Opciones para reducir el sobreajuste

Las principales formas de reducir el sobreajuste:

1. Reducir la cantidad de descriptores.
   - Manualmente o con métodos automáticos de selección de modelo.
   - Perdemos información codificada en los descriptores que eliminamos.
2. Usar *regularización*.
   - Mantenemos todos los descriptores pero los ponderamos.

*** Cost function

Introducimos un parámetro de regularización $\lambda$ en la función de costo, que pondera la suma de los cuadrados de los parámetros $\theta$.

- /Creo que este tipo de regularización tiene un nombre/.
- /Usamos el cuadrado para que no se cancelen entre sí y porque es derivable supongo/.

Por ejemplo, para /MSE/:

\[ J(\theta,x,h(x),\lambda) =  \frac{1}{2m} \left( \sum_{i=1}^{m} \left[ h(\theta,x^{(i)}) - y^{(i)} \right]^2 + \lambda \sum_{j=1}^{n} \theta_j^2 \right)  \]

- Se suele omitir la ordenada al origen, término de sesgo o *intercepto* $\theta_0$ porque no afecta mucho a los resultados.
  - /Me parece que debe haber una razón más interesante, porque esta decisión hace que tengamos que calcular las funciones de costo de forma separada para \(\theta_0\)/.
    - En verdad es incorrecto pretender que el intercepto sea pequeño. Ver abajo en [[*Buscar por qué no usamos $\theta_0$]].


Lo que buscamos es tener parámetros pequeños, lo que hace que la función de hipótesis sea suave, simple.

Más adelante vamos a ver formas de determinar el valor del parámetro de regularización $\lambda$ para que funcione. Si es muy grande, hay subajuste, y si es muy chico seguimos con sobreajuste.

****** DONE Buscar por qué no usamos $\theta_0$
CLOSED: [2020-04-20 lun 00:53]

El intercepto es nuestro factor de prejuicio que es independente de los descriptores. Es nuestra respuesta por defecto cuando no tenemos información, y no tiene por qué ser un valor chico. Por tanto no lo introducimos en el algoritmo de regularización.

Recordemos que el intercepto es una variable independiente, la ordenada al origen. Lo introducimos dentro del vector de parámetros solo por conveniencia, para simplificar los cálculos.

*** Regularized linear regression

La función de costo usando error cuadrático medio y regresión lineal nos queda

\[ J(\theta,x,h(x),\lambda) =  \frac{1}{2m} \left( \sum_{i=1}^{m} \left[ h(\theta,x^{(i)}) - y^{(i)} \right]^2 + \lambda \sum_{j=1}^{n} \theta_j^2 \right)  \]

Nótese que $j$ empieza en $1$. La regla de actualización derivada es:

\[ \theta_j[n+1] := {\theta}_j[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)} \quad \text{si} \quad j=0 \]

\[ \theta_j[n+1] := {\theta}_j[n] - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)} + \frac{\lambda}{m} \theta_j \quad \text{si} \quad j>0 \]

Factorizando $\theta_j$ de esta última ecuación nos queda

\[ \theta_j[n+1] := {\theta}_j[n](1 - \frac{\alpha\lambda}{m}) - \frac{\alpha}{m}  \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)} ) x_j^{(i)}  \quad \text{si} \quad j>0 \]

El factor $(1 - \frac{\alpha\lambda}{m})$ nos indica que en todas las actualizaciones se comienza reduciendo el valor anterior de los parámetros.

**** Forma matricial/vectorizada

La forma matricial/vectorizada queda

\[ J(\theta, X, \lambda) = \frac{1}{2m} \sum (X\theta - Y)^2 + \frac{\lambda}{2m} \theta(1:n)^T \theta(1:n) \]


La actualización necesita 2 etapas: la primera es el cálculo normal sin regularización, y de aquí guardamos $\theta_0$; en la segunda sumamos el termino de regularización; y finalmente reemplazamos con el $\theta_0$ encontrado anteriormente.

\[ \theta[i+1]^{(a)} := \theta[i] - \frac{\alpha}{m} X^T (h(X \theta) - Y) \]
\[ \theta_0[i+1]^{} := \theta[i+1]^{(a)}(0) \]
\[ \theta[i+1]^{} := \theta[i+1]^{(a)} + \frac{\lambda}{2m} \theta[i] \]
\[ \theta[i+1](0) := \theta_0[i+1]  \]


------------

**** La ecuación normal con regularización

La ecuación normal era

\[  \theta = [ ( X^T \times X)^{-1} \times X^T ] \times Y  \]

Agregamos un término de regularización:

\[  \theta = [ ( X^T \times X \times \lambda L)^{-1} \times X^T ] \times Y  \]

Donde L es una matriz diagonal cuyo primer elemento de la diagonal principal es $0$ e indica que no queremos que la regularización afecte al parámetro \theta_0 .

Este termino de regularización *hace que esa matriz sea invertible aunque se trate de un sistema subdeterminado* (siempre que $\lambda>0$).
  - En las [[https://www.coursera.org/learn/machine-learning/discussions/weeks/3/threads/poUNvD1-EeakuhJbRt69hQ][preguntas frecuentes de la semana 3]] dicen que [[http://web.mit.edu/zoya/www/linearRegression.pdf][acá hay un "boceto de demonstración"]].

*** Regularized logistic regression

La función de costo de la regresión logística con regularización queda:

\[  J(h_\theta(x), \lambda) = J(h(\theta,x)) = \frac{1}{m} \sum_{i=1}^m \left[-y^{(i)} \log(h_\theta(x^{(i)})) - (1-y^{(i)}) \log(1-h_\theta(x^{(i)}))  \right] + \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2 \]

La forma vectorizada/matricial:

\[ J(h(\theta,X), \lambda) = \frac{1}{m} \left[ -Y^T \log(h(X\theta)) - (1-Y)^T \log(1-h(X\theta)) \right] + \frac{\lambda}{2m} \theta(1:n)^T \theta(1:n) \]

La regla de actualización es igual que para regresión lineal con /MSE/, calculando por separado $\theta_0$.





** Review

*** Quiz: Regularization

- Agregar nuevos descriptores nos da una hipótesis igual o mejor a la que tenemos antes de agregarlos, en los datos de entrenamiento/modelado.
  - Asumo que asume convergencia.

*** Programming assignment: logistic regression

- Corregí algunas funciones vectorizadas de mis notas.
- El logaritmo es logaritmo natural, no base 10. Por tanto debería escribir $ln$ en lugar de $log$, aunque en Octave la función es ~log~.
- /Cross entropy/
- Usamos /feature mapping/ para crear nuevos descriptores a partir de los 2 que teníamos. Los nuevos son todas las combinaciones lineales posibles de descriptores, hasta cierto grado.

#+begin_src octave
  function out = mapFeature(X1, X2)
  % MAPFEATURE Feature mapping function to polynomial features
  %
  %   MAPFEATURE(X1, X2) maps the two input features
  %   to quadratic features used in the regularization exercise.
  %
  %   Returns a new feature array with more features, comprising of 
  %   X1, X2, X1.^2, X2.^2, X1*X2, X1*X2.^2, etc..
  %
  %   Inputs X1, X2 must be the same size
  %

    degree = 6;
    out = ones(size(X1(:,1)));
    for i = 1:degree
      for j = 0:i
        out(:, end+1) = (X1.^(i-j)).*(X2.^j);
      end
    end

  end

  % ---------
  % Add Polynomial Features
  % Note that mapFeature also adds a column of ones for us, so the intercept
  % term is handled
  X = mapFeature(X(:,1), X(:,2));

#+end_src

- $\theta_0$: manejé los distintos gradientes así:

#+begin_src octave
  grad = (1/m) * X'*(sigmoid(X*theta) - y);
  grad0 = grad(1);
  grad = grad + (lambda/m).*theta;
  grad(1) = grad0;
#+end_src

* Semana 4

Empezamos a ver redes neuronales.

** Motivations

*** Non-linear hypotheses

Las redes neuronales son de los clasificadores más avanzados y usados hoy en día.

Para problemas poco lineales, la regresión logística empieza a necesitar muchos descriptores. Demasiados. Sea por ejemplo un problema con dos descriptores $x_1$ y $x_2$. Si queremos más expresividad de clasificación y añadimos como descriptores sintéticos todos los productos de segundo orden, tenemos $x_1^2 , x_2^2, x_1 x_2$, y tendríamos un total de 5 descriptores. Este total crece como $O(\frac{n^2}{2})$. Los de tercer orden crecen como $O(n^3)$.

Hay muchos problemas que de entrada ya están definidos por muchos descriptores. Un ejemplo: las imágenes digitales. Por ejemplo, una imagen de 100\times100px requeriría aproximadamente 50 millones de descriptores de segundo grado.


*** Neurons and the brain

- /The "one learning algorithm" hypotesis/: el cerebro tiene el mismo algoritmo de aprendizaje siempre, y se adapta a cualquier entrada.

****** TODO https://www.lesswrong.com/posts/9Yc7Pp7szcjPgPsjf/the-brain-as-a-universal-learning-machine

****** TODO https://www.youtube.com/watch?v=AY4ajbu_G3k

****** TODO https://www.youtube.com/watch?v=NKpuX_yzdYs

****** TODO https://www.youtube.com/watch?v=zIwLWfaAg-8

****** TODO https://www.wired.com/2013/05/neuro-artificial-intelligence/

** Neural networks

*** Model representation I

Está largo de escribir así que copio la imagen:

[[./imgs/004-neural-network-model.png]]

Algo de nomenclatura y convenciones:

- Es equivalente hablar de una *unidad*, una *neurona*, la salida de una neurona o la *activación* de una neurona. Siempre hablamos del resultado de la función de activación ante ciertas entradas y parámetros o pesos: $g(\theta,x)$. La neurona en sí no tiene significado en el modelo, aunque lo tiene en el diagrama.
  - La unidad 1 de la capa 2 es $a_1^{(2)}$.
  - Se suele omitir la unidad de sesgo de cada capa, $a_0^{(j)}$, porque vale siempre 1. Esta es la que se multiplica por $\theta_0$. /DISCREPO/.
- $h_{\Theta}^{}(\vec{x}^{})$ es la salida final de la red neuronal, en función de las entradas.
- La función de activación típica es la función logística/sigmoidea.
- A los parámetros de la función también les decimos *pesos*.
  - \Theta^{(j)} es la matriz de pesos que relaciona la capa $j$ con la siguiente $j+1$. Si una capa $j$ tiene $s_j$ unidades y la siguiente es $j+1$ con $s_{j+1}$ unidades, la dimensión de $\Theta^{(j)}$ será $(s_{j+1})\times(s_j+1)$ (entradas \times (salidas + entradas independientes)); el $+1$ es por la unidad de sesgo.
- En los diagramas se funden axones y dendritas de capas conectadas, adyacentes. Entonces los únicos axones son los de la capa de salida.
- A las capas que no son de salida o entrada se les suele llamar *capas ocultas*.

*** Model representation II

Este modelo básico de red neuronal es un conjunto de funciones logísticas encadenadas. La forma de conectar las neuronas (arquitectura) le va a permitir aprender funciones no lineales complejas.

En forma vectorizada y asumiendo la misma función de activación $g^{(j)}$ para todas las neuronas:

\[ h_{\Theta}^{}(\vec{x}^{}) = h(g, \vec{x}, \Theta) \]
\[ \vec{a}^{(j) }= g_{}^{}(\vec{z}^{(j)}) = g(\Theta^{(j-1)} \vec{a}^{(j-1)})  \]

** Applications

*** Examples and intuitions I

Con una neurona de 3 entradas puedo calcular las funciones AND y OR.

*** Examples and intuitions II

Ejemplo de XNOR.

*** Multiclass classification

Para clasificación multiclase solo tenemos que tener tantas salidas como clases. Luego, codificamos la salida como un vector "/one hot/", donde todos los elementos son $0$ menos el de la salida correcta, que es $1$.

Las salidas de la red $\vec{\hat{y}} = h_\Theta(\vec{x})$ no son una distribución de probabilidad, no necesariamente suman 1. Son la salida de distintas sigmoideas, y cada una representa la confianza que tiene ese clasificador.

** Review

*** Quiz: Neural networks: representation

*** Programming assignment: multi-class classificatin and neural networks

* Semana 5

Vamos a ver el algoritmo de retropropagación o propagación hacia atrás (/backpropagation/) para el aprendizaje de redes neuronales.

** Cost function and backpropagation

*** Cost function

Para optimizar un conjunto de parámetros $\Theta$ necesitamos primero definir una función de costo a minimizar.

Algunas definiciones:

- $K$ es la cantidad de salidas de la red.
  - Usamos $k$ para indizarlas.
- $L$ es la cantidad de capas de nuestra red.
  - Usamos $l$ para indizarlas.
- $s_l$ es la cantidad de neuronas/unidades de la capa $l$, *sin contar la unidad de sesgo $a_0^{(l)}$*.

La función de costo es una extensión de la regularizada que usábamos para regresión logística.

- Sumamos los errores de todas las salidas.
- Regularizamos todos los parámetros $\theta$ de las matrices $\Theta$, excepto aquellos que relacionan unidades de sesgo. Estos son corresponden a +la primera fila y+ la primera columna de cada $\Theta$.

\[  J(\Theta, \lambda) = \frac{1}{m} \sum_{k=1}^K \sum_{i=1}^m \left[-y_k^{(i)} \log(h_\Theta(x^{(i)})_k) - (1-y_k^{(i)}) \log(1-h_\Theta(x^{(i)})_k)  \right] + \frac{\lambda}{2m} \sum_{l=1}^L \sum_{v=0}^{s_{l+1}} \sum_{j=1}^{s_l} (\Theta_{v,j}^{(l)})^2 \]

- /Yo voy a usar $v$ donde él usa OTRA $i$/.


*** Backpropagation algorithm

Esto está complicado así que nos lo dan sin demostraciones.

El algoritmo de retropropagación o propagación hacia atrás sirve para calcular el gradiente de la función de costo en función de los parámetros. Luego usamos este gradiente *en algún algoritmo de optimización* como el descenso por el gradiente, para encontrar los parámetros que minimizan la función de costo.

\[  \frac{\partial J(\Theta)}{\partial \Theta_{v,j}^{(l)} } = D_{v,j}^{(l)}  \]

\[ D_{v,j}^{(l)} = \frac{1}{m} \Delta_{v,j}^{(l)} + \lambda \Theta_{v,j}^{(l)} \quad \text{si} \quad j=0  \]

\[ D_{v,j}^{(l)} = \frac{1}{m} \Delta_{v,j}^{(l)} \quad \text{si} \quad j\ne0  \]

$\Delta_{v,j}^{(l)}$ son matrices en las que vamos acumulando los errores de cada unidad de cada capa, para cada ejemplo de entrada. El proceso es:

1. Para cada ejemplo $x{(i)}$:
   1. Calculamos las salidas de la red, propagando hacia adelante.
   2. Calculamos los errores, propagando hacia atrás.

\[  \Delta_{v,j}^{(l)} [n+1] := \Delta_{v,j}^{(l)} [n] + \vec{a}_j^{(l)} \vec{\delta}_{v}^{(l+1)} \]

De forma vectorizada/matricial:

\[ \Delta^{(l)}[n+1] := \Delta^{(l)}[n] + \delta^{(l+1)} (a^{(l)})^T   \]


$\vec{\delta}^{(l)}$ es un vector de los errores para cada capa. Si no entiendo mal, es la derivada de $g$ en el punto determinado por sus entradas, multiplicado por el avance del error retropropagado.

\[  \vec{\delta}^{(l=L)} :=  \vec{a}^{(l)} - \vec{y}^{}  \]

\[  \vec{\delta}^{( 1 \lt l \lt L )} := (\Theta^{(l)})^T \vec{\delta}^{(l+1)} * \vec{g'}(z^{(l)})  \]

\[ \vec{g'} (z^{(l)}) = \vec{a}^{(l)} .* (\vec{1} - \vec{a}^{(l)} )  \]





*** Backpropagation intuition

Los términos $\delta$ son los "errores" de predicción de cada unidad. Más técnicamente:

\[  \delta_j^{(l)} = \frac{\partial costo(h_\Theta, x^{(i)})}{\partial z_j^{(l)}}   \]

Así como cada $z^{(l)}$ es una suma pesada de las entradas a esa unidad, cada $\delta^{(l)}$ es una suma pesada de las entradas a esa unidad, recorriendo el grafo al revés, desde las salidas a hacia las entradas.

** Backpropagation in practice

*** Implementation note: unrolling parameters

Muchos algoritmos de optimización esperan vectores. Para trabajar con nuestras matrices $\Theta$ de parámetros y $D$ de gradientes, lo que hacemos es juntar todos los elementos y expresarlos como vector. Luego las reconstruimos en donde sea necesario.

En Octave:

#+begin_src octave
  Theta1 = rand(4,3);  % 4x3
  Theta2 = rand(2,4);  % 2x4
  ThetaVec = [Theta1(:); Theta2(:)];  % 20x1
  % [J, DVec]  = costFunction(ThetaVec, X, Y)  % Adentro reconstruimos ThetaVec
  ThetaVecOptimized = fminunc(...)
  Theta1 = reshape(ThetaVecOptimized(1:11), 4,3)
#+end_src

*** Gradient checking

Para verificar que nuestro algoritmo de retropropagación esté funcionando bien, podemos comparar los gradientes $D$ calculados con unos calculados manualmente usando una aproximación de la derivada en el punto. Andrew sugiere usar una aproximación de doble lado:

\[  \frac{\partial J(\Theta)}{\partial \Theta}   \approx  \frac{J(\Theta + \epsilon) - J(\Theta - \epsilon)}{2 \epsilon}\]

Calculamos esto para cada uno de los parámetros $\theta$ del vector desenrollado a partir de las matrices $\Theta$. Calculamos para cada parámetro, manteniendo el resto fijos; es la derivada parcial.

*¡Nótese que podríamos optimizar con esto!* El problema es que es computacionalmente mucho más costoso que el algoritmo de retropropagación. Implica recalcular la función de costo 2 veces para cada parámetro de las matrices. Por lo tanto, solo lo deberíamos usar para depurar nuestro código, pero luego desactivarlo.

*** Random initialization

Si inicializamos los parámetros $\theta$ de las matrices $\Theta$ todos con el mismo valor, en cada iteración de propagación hacia adelante terminamos con las mismas activaciones en cada unidad de una misma capa; y en cada iteración de propagación hacia atrás terminamos con los mismos errores $\delta$. Esto implica que todas las unidades de una capa terminan calculando los mismos descriptores. Esto se llama el *problema de los caminos simétricos*. /Supongo que se da porque todas las unidades están conectadas de la misma manera, quizás no sería necesario si las unidades se conectaran de forma distinta/.

La forma de solucionar el problema es romper la simetría (/simmetry breaking/). Para esto debemos inicializar los parámetros con valores distintos. Andrew propone inicializarlos con valores aleatorios (distribución uniforme) en un intervalo $[-\epsilon, \epsilon]$ para un valor $\epsilon$ pequeño cualquiera (propone un $\epsilon<1$).

*** Putting it together

- La arquitectura es el patrón de conexión entre las neuronas.
  - Lo más básico es tener una capa oculta (pero no dice de cuántas unidades).
  - Una buena heurística es tener tantas capas ocultas como unidades de entrada.
- Recordamos que el algoritmo de retropropagación es un algoritmo para calcular el gradiente de la función de costo respecto a la variación de los parámetros; la optimización se hace con un algoritmo genérico de optimización, como el descenso por el gradiente.
- $J(\Theta)$ no es un espacio convexo en las redes neuronales. Esto implica que quizás no alcanzamos el mínimo global, pero dice Andrew que esto no suele ser un problema en la realidad.

** Applications of neural networks

*** Autonomous driving

Jeep automanejado en 1992.

** Review

*** Quiz: Neural networks: learning

*** Programming assignment: neural network learning

- Usé una forma vectorizada de la función de costo, según algunas pistas que encontré en las notas del curso. En ellas usé la /traza/ de una matriz, para trabajar con muchas salidas.

#+begin_src octave
  % Cálculo de la función de costo
  y_onehot = zeros(num_labels, m);  % s3xm
  for i = 1:m  % cada columna
    y_onehot(y(i),i) = 1;
  endfor

  % Cálculo totalmente vectorizado:
  % Uso la traza (suma de la diagonal principal), pero también podría ser la suma de
  %  todos los elementos del producto elemento a elemento.
  J = (1/m) * (trace(-y_onehot * log(a3')) - trace((1.-y_onehot) * log(1.-a3')) );

  % Agrego regularización
  J = J + (lambda/(2*m)) * (sum(sum(Theta1(:,2:end).^2)) +  sum(sum(Theta2(:,2:end).^2)));
#+end_src
 
Sin regularización:

\[ J = \frac{1}{m} \times \left( tr( Y \times -log(\hat{Y}) ) - tr(  (1-Y) \times -log(1-\hat{Y})  ) \right)  \]

\[ J = \frac{1}{m} \times \left(  \sum \left[ Y \odot -log(\hat{Y})  \right] - \sum \left[ (1-Y) \odot -log(1 - \hat{Y})  \right] \right)   \]

- One hot.
- Implementé una forma vectorizada de la retropropagación, basada en lo que encontré [[https://medium.com/secure-and-private-ai-math-blogging-competition/https-medium-com-fadymorris-understanding-vectorized-implementation-of-neural-networks-dae4115ca185][acá]].

#+begin_src octave
  % Retropropagación
  % https://medium.com/secure-and-private-ai-math-blogging-competition/https-medium-com-fadymorris-understanding-vectorized-implementation-of-neural-networks-dae4115ca185
  delta3 = a3 - y_onehot;
  delta2 = (Theta2' * delta3) .* sigmoidGradient([ones(1,size(z2,2));z2]);
  Delta2 = delta3 * a2';
  Delta1 = delta2(2:end, :) * a1';
  D2 = (1/m) * Delta2 + (lambda/m) * [zeros(size(Theta2,1),1) , Theta2(:,2:end)];
  D1 = (1/m) * Delta1 + (lambda/m) * [zeros(size(Theta1,1),1), Theta1(:,2:end)];
#+end_src

* Semana 6

En esta semana vamos a ver cómo evaluar nuestros modelos.

- Advice for applying machine learning
- Machine learning system design

#+begin_quote
To optimize a machine learning algorithm, you’ll need to first understand where the biggest improvements can be made. [...]

When you're applying machine learning to real problems, a solid grasp of this week's content will easily save you a large amount of work.
#+end_quote

** Evaluating a learning algorithm

*** Deciding what to try next

Algunas cosas que podemos cambiar para intentar mejorar nuestros algoritmos si no estamos satisfechos con los resultados:
- Obtener más ejemplos
- Generar más descriptores / proponer un modelo más complejo.
  - Sintéticos (modelos más complejos, descriptores polinomiales)
  - Reales
- Usar menos descriptores / proponer un modelo más simple.
- Variar el factor de regularización $\lambda$.
- Aumentar las iteraciones buscando la convergencia.

Algunas de esas decisiones pueden ser muy costosas o largas. Vamos a ver herramientas de diagnóstico que nos pueden dar pista sobre qué es mejor probar.

*** Evaluating a hypothesis

Dividimos el conjunto de datos en 2 subconjuntos de muestras aleatorias:

1. Conjunto de entrenamiento. Sobre estos datos optimizamos nuestros parámetros.
2. Conjunto de evaluación/prueba. Sobre estos datos evaluamos el desempeño de nuestro modelo.

Para evaluar el desempeño Andrew propone:

- En regresión:
  - MSE
- En clasificación:
  - La misma función de costo que usamos para optimizar.
  - Error medio de predicción / error de clasificación 0/1. Es el error usando las salidas /one-hot/.

Tanto en la función de costo $J_{validation}$ como en la $J_{test}$ _no incluímos los términos de regularización_.


*** Model selection and train/validation/test sets

Andrew propone usar usar un tercer subconjunto, intermedio, sobre el cuál podemos evaluar *hiperparámetros* o parámetros de más alto nivel. Entonces:

1. Conjunto de entrenamiento
   - 60%
   - Aquí ajustamos los parámetros básicos de nuestro modelo, $\theta$.
2. Conjunto de validación (cruzada)
   - 20%
   - Acá ajustamos parámetros que definen la estructura de nuestro modelo. Por ejemplo, el grado del polinomio de ajuste. O sea que ajustamos los $\theta$ de modelos con distintos grados $d$ y elegimos un $d$ según su desempeño en este conjunto.
3. Conjunto de evaluación
   - 20%
   - Acá estimamos el desempeño real de nuestro modelo.

**** Discusión

No me queda claro por qué no podríamos ajustar parámetros e hiperparámetros en simultáneo. ¿Y con qué criterio distinguimos los unos de los otros?

- Otro hiperparámetro podría ser un umbral de clasificación.


** Bias vs variance

*** Diagnosing bias vs variance

Cuando tenemos mucho error en el conjunto de validación, hay una forma de saber si es error de sesgo alto o error de varianza alta:
- Si $J_{train} \approx J_{val}$ y ambos son altos, entonces el modelo tiene sesgo alto y está subajustando.
- Si $J_{val} \gg J_{train}$ (suponiendo que estamos minimizando el error), entonces el modelo tiene varianza alta y está sobreajustando.

[[./imgs/005-high-bias-vs-high-variance.png]]


*** Regularization and bias/variance

El comportamiento de las funciones de costo respecto a $\lambda$ es espejado al que se observa según el grado del polinomio; esto es, $J_train$ crece proporcionalmente a $\lambda$.

Andrew propone elegir un conjunto de valores posibles de $\lambda$ y evaluarlos para cada uno de los posibles valores de $d$.

Algo interesante comentado en [[https://www.coursera.org/learn/machine-learning/discussions/weeks/6/threads/P3Cp9j_ZEeaDRA5SxbW7qQ][las preguntas frecuentes de la semana 6]], respecto a hacerlo de forma secuencial:

#+begin_quote
Q5) What does Prof Ng mean when he says we're "fitting another parameter 'd' to the CV set"?

We use the CV set to make adjustments to the model. Prof Ng is referring to adjusting both the regularization and the polynomial degree.

But there is a problem.

Each subset of data can only be used for one purpose. If you have one CV set and use it to adjust the regularization, then you cannot continue using the same CV set to select the best polynomial degree. This would result in overfitting the CV set.

One solution is to further split the data set so you have two CV sets, and use one to adjust the regularization, and the second to select the best polynomial degree. But this increases the amount of labeled data that is needed.

A second solution is possible. You can create all possible combinations of the parameters 'd' and lambda, and evaluate each combination using only one validation set. You then select the combination that gives the lowest validation set error. Only one CV set is needed.
#+end_quote

*** Learning curves

Las gráficas de aprendizaje muestran la variación de los errores de entrenamiento y validación ante el cambio de cantidad de muestras de entrenamiento, para una complejidad de modelo fija.

Cuando nuestro modelo sufre de alto sesgo, vemos que $J_{train}$ y $J_{CV}$ pronto se estancan en un valor. El modelo no puede explicar más variación.

[[./imgs/006-1-learning-curves.png]]

Para un modelo con alta varianza, las curvas varían lentamente y tienden a converger, pero van a necesitar de muchos ejemplos para poder encontrar la generalización.

[[./imgs/006-2-learning-curves.png]]

Estaría bueno tener una gráfica de como varían esas curvas al cambiar la complejidad del modelo...

*** Deciding what to do next revisited

--------

La regularización sirve para forzar la exploración de todo el espacio de parámetros, y bajo la suposición de que los descriptores están normalizados. La regularización intenta que todos los descriptores afecten en la decisión, y esto puede ser mentira. Me parece que sería mejor atacar el problema con la complejidad del modelo, no con regularización.

** Review

*** Quiz: advice for applying machine learning

*** Programming assignment: regularized linear regression and bias/variance

** Building a spam classifier

*** Prioritizing what to work on

*** Error analysis

- Hacer una implementación rápida de un clasificador y sus pruebas, para tener información de en qué paso gastar tiempo a continuación. Esto es importante.
- Podemos construir curvas de aprendizaje para ver si necesitamos más o menos ejemplos, modelos más complejos, etcétera.
- Podemos analizar manualmente los casos mal clasificados (o con mucho error en caso de regresión, supongo), para intentar observar patrones.
- Siempre es bueno tener una única métrica de evaluación. Esta nos va a permitir discernir si una estrategia es buena o no.
- Es muy recomendable evaluar las cosas en los conjuntos de validación cruzada, no en el conjunto de evaluación. Nunca ajustamos nada en el conjunto de evaluación.

** Handling skewed data

*** Error metrics for skewed classes

En clasificación (¿binaria?) en la distribución de las clases está muy sesgada (una de las clases es muy rara, tiene poca frecuencia), no es apropiado usar la precisión como métrica. Aquí corresponde analizar la precisión y la exhaustividad (/recall/).

[[./imgs/007- precisionrecall.svg.png]]

Podemos variar el comportamiento del modelo al modificar el umbral de decisión a la salida (esto es un hiperparámetro, y lo evaluamos en el conjunto de validación).

*** Trading off precision and recall

Una métrica que incluye la precisión y la exhaustividad es el Valor F (/F score/), que se define como la media armónica (ponderada) de la precisión y exhaustividad.

\[ F_\beta = (1 + \beta^2) \frac{precision \cdot recall}{(\beta^2 \cdot precision) + recall}  \]

$\beta$ es cuántas veces es la exhaustividad más importante que la precisión. Normalmente se usa $\beta = 1$, obteniendo la métrica $F_1$ que pondera de igual manera la precisión y la exhaustividad.

\[ F_\beta \in [0, 1] \]


** Using large datasets

*** Data for machine learning

Si tenemos

- un conjunto de descriptores suficientemente expresivo como para determinar correctamente la salida a partir de ellos (si un humano experto puede hacerlo a partir de esas entradas, el sistema también podrá);
- un modelo complejo, de poco sesgo, que no se va a sobreajustar;

entonces la forma de mejorar los resultados es con más y más datos de entrenamiento.

En la publicación [[https://www.microsoft.com/en-us/research/publication/mitigating-the-paucity-of-data-problem-exploring-the-effect-of-training-corpus-size-on-classifier-performance-for-natural-language-processing/]["Mitigating the Paucity-of-Data Problem: Exploring the Effect of Training Corpus Size on Classifier Performance for Natural Language Processing" de Michele Banko y Eric Brill]] se prueban varios modelos complejos y se observa que su desempeño tiende a ser el mismo, y además crece monotónicamente con la cantidad de ejemplos de entrenamiento.

** Review

*** Quiz: machine learning system design

* Semana 7

Vamos a ver /SVMs/: máquinas de vector soporte / máquinas de soporte vectorial.

** Large margin classification

*** Optimization objective

Vamos a ver un algoritmo de aprendizaje supervisado más: las máquinas de soporte vectorial. Primero definimos una función de costo a optimizar, que es similar a la que usamos para regresión logística.

\[  J(\theta) = C \sum_{i=1}^m \left[ y^{(i)} cost_1(\theta x^{(i)}) + (1-y^{(i)}) cost_0(1 - \theta x^{(i)}) \right]  + \frac{1}{2}  \sum_{v=1}^{n} \theta_v  \]

- _Este es un caso de clasificación binaria_.
- $C$ es equivalente a $1/\lambda$, y es un factor que sirve para ponderar la optimización del primer término sobre el otro.
- Las funciones $cost_0$ y $cost_1$ son muy similares al menos logaritmo de la función logística (lo que estaba ahí en la función de costo que usamos para regresión logística). Parecen funciones rampa, con base en $0$ y crecimiento en $1$ y $-1$ respectivamente.

La función de hipótesis (que todavía no vemos) no emite probabilidades, sino una salida discreta, que definimos con un umbral en $0$:

\[  h_\theta(x) = 1 \quad si \quad \theta^T x \ge 0   \]
\[  h_\theta(x) = 0 \quad si \quad \theta^T x \lt 0  \]

-------

Resulta que $cost_0$ y $cost_1$ se llaman funciónes de pérdida bisagra ([[https://en.wikipedia.org/wiki/Hinge_loss][/hinge loss/]]).

\[ l(\hat{y}) = \max(0, 1-t \cdot \hat{y}) \]

donde \( y = \pm  1 \) es la salida deseada.

Resulta además que la función de hipótesis es simplemente una combinación lineal de los descriptores de entrada, definida por los parámetros y a la que luego se le aplica un umbral en 0. Más tarde vamos a remplazar los descriptores, para lograr fronteras no lineales.

*** Large margin intuition

La minimización nos da parámetros que definen una frontera óptima de separación entre clases. La frontera es óptima en términos de maximizar los márgenes, los espacios entre la frontera y los datos.

- A menor C, más regularización y menos sobreajuste.

****** DONE Revisar esto y abajo
CLOSED: [2020-05-13 mié 20:12]

*** Mathematics behind large margin classification

No se entendió.

Ya lo entendí... sirve para justificar la explicación del título anterior.

** Kernels

*** Kernels I



*** Kernels II

En estos videos entendí un poco más y voy a intentar explicar todo acá.

En las /SVMs/ nuestra función de hipótesis define un hiperplano de decisión. La optimización maximiza el margen entre ese hiperplano y los ejemplos de entrenamiento, a ambos lados del hiperplano.

Una forma de hacerlo sería como lo hicimos en regresión lineal: agregando descriptores de mayor orden, a partir de los descriptores iniciales.

Acá hacemos otra cosa: mapeamos nuestro conjunto de descriptores a otro conjunto de descriptores (no necesariamente del mismo tamaño). Este nuevo conjunto son distancias definidas por funciones de similitud / funciones de distancia. ¿Distancia a dónde? La distancia es en el espacio de descriptores originales, entre las entradas y puntos de referencia (/landmarks/). Como puntos de referencia usamos /cada uno de los ejemplos de entrenamiento/.

A las funciones de distancia también se denomina /kernels/ o núcleos. Ahora vimos un /kernel/ gaussiano:

\[  f_i = similarity(x, l^{(i)} ) = e^{\frac{||x - l{(i)}||^2}{s\sigma^2}} = exp(\frac{||x - l{(i)}||^2}{s\sigma^2}) \]

- Esta es una gaussiana de altura 1, y $\sigma$ define su "anchura".
  - La similaridad será $\approx1$ si la entrada está cerca de esa referencia, y $0$ si está lejos.
- Mientras más grande $\sigma$, la función es menos discriminativa, más suavizada. Entonces $\sigma$ actúa como otro parámetro de regularización.

Nótese que luego deberemos mapear cada entrada al espacio de distancias, y ahí predecir la clase.

*Entonces al aplicar el /kernel/ estamos convirtiendo un problema no lineal en uno lineal*. También hacíamos esto al agregar parámetros no lineales en regresión lineal o logística.

¿Por qué no usamos estas funciones de distancia en regresión lineal? En realidad si podemos, pero por cierta matemática de la implementación, esto es mucho más rápido en las SVMs. _Nótese que el espacio transformado de descriptores es de $m$ dimensiones, donde $m$ es el número de ejemplos de entrenamiento_.

** SVMs in practice

*** Using an SVM

Si bien hay más funciones de distancia o /kernels/ normalmente se usan dos:
 - /kernel/ lineal (en realidad, sin /kernel/) es cuando no usamos función de distancia (lo que hicimos al principio) y $\hat{y}=1 \quad si \quad h(\theta^T x) \ge 0$. Esto es muy similar en resultados a una regresión logística.
 - /kernel/ gaussiano.

Las soluciones se encuentran con algoritmos especializados para /SVM/. Les tenemos que dar la función de distancia y listo.

*Es importante normalizar los descriptores (hacer /feature scaling/) antes de calcular nos nuevos descriptores de distancia*. Al normalizar hacemos comparables los distintos descriptores, *ponderamos su información de igual manera*.

La función de costo que optimizamos (definida anteriormente) es convexa, y por tanto siempre encontramos el mínimo global.

Los algoritmos pueden soportar multiclase. Si no, hacemos el clásico "uno contra todos".
- Para $K$ clases necesitamos $K$ clasificadores.

**** Cuándo usar

Sean
- $n$ el número de descriptores/parámetros.
- $m$ el número de ejemplos de entrenamiento.


Entonces

1. Si $\frac{n}{m} \ge 10$, el sistema está subdeterminado y es mejor intentar con un modelo simple. Tenemos pocos datos y con un modelo complejo nos arriesgamos a sobreajustar. Aquí podemos usar regresión logística o /SVM/ con /kernel/ lineal, que es equivalente.

2. Si $\frac{m}{n} \ge 10$, el sistema está sobredeterminado. Acá deberíamos usar un modelo complejo que permita capturar la influencia de todos los descriptores. Aquí es donde brillan las /SVM/ con /kernel/ gaussiano.

  - Si $m$ es muy grande ($\gt10000$), entonces una /SVM/ con /kernel/ gaussiano tarda mucho en entrenar. Entonces podemos usar regresión logística o un /kernel/ lineal, junto con la adición de nuevos descriptores sintéticos. Esto es solo por una limitación de poder de cómputo.

Dice Andrew que en ambos casos también podríamos usar redes neuronales, pero estas tardan más en entrenar.

** Review

*** Quiz: support vector machines

*** Programming assignment SVMs

Usé ~containers.Map~ para crear un mapeo, como los diccionarios de Python.

** Otras cosas

*** https://www.youtube.com/watch?v=3liCbRZPrZA SVM with polynomial kernel visualization

#+begin_quote
Technically what is visualized here isn't "the kernel trick". This is the general idea of how nonlinearly projecting some points into a higher-dimensional feature space makes linear classifiers more powerful. You can do this with out SVMs. Just compute the high-dimensional features corresponding to your data, then use logistic regression or whatever. Trouble is, if the higher-dimensional space is really big, this could be expensive. The "kernel trick" is computational trick that SVMs use to compute the inner product between the high-dimensional features corresponding to two points with out explicitly computing the high-dimensional features. (For certain special feature spaces.)

But this is definitely a cool visualization of the value of feature spaces! 
#+end_quote
https://news.ycombinator.com/item?id=1299733


*** https://ranvir.xyz/blog/svm-support-vector-machines-in-machine-learning/

Discusión en https://news.ycombinator.com/item?id=23035120

- https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers
- http://www.stat.columbia.edu/~gelman/book/
- "Statistical Rethinking" by McElreath
- Introduction to Statistical Learning https://faculty.marshall.usc.edu/gareth-james/ISL/
- Elements of Statistical Learning https://web.stanford.edu/~hastie/ElemStatLearn/

* Semana 8: Unsupervised learning

Vamos a ver algo de aprendizaje no supervisado. Acá no tenemos entradas y salidas etiquetadas; solo un conjunto de datos de entrada de los cuáles queremos entender la estructura subyacente.
También vemos algo de reducción de la dimensionalidad del problema.

** Clustering

*** Unsupervised learning: introduction

Buscamos ver si hay conjuntos de datos que presentan características similares, con las cuáles podríamos agruparlos.

También podemos usar algoritmos de agrupamiento cuando nosotros queremos agrupar los datos en un número arbitrario de grupos. Por ejemplo, podríamos querer tener K segmentos de mercado.

*** K-means algorithm

*Acá trabajamos los ejemplos en sus $n$ dimensiones originales; no agregamos el $x_0=1$ que nos facilitaba trabajar con los interceptos.*

Sean:

- $K$: el número de grupos que queremos tener, indexado con $k$.
- $\mu_k$: el centroide / centro de masa del grupo $k$.
- $c^{(i)}$: el grupo asignado al ejemplo $i$. Es el grupo que tiene la menor distancia entre su centroide y el ejemplo. Hay varias métricas de distancia; la más común es la euclidea.
- $\mu_{c^{(i)}}$: el centroide del grupo / /cluster/ del ejemplo $i$.


El algoritmo es:

- Hasta la convergencia o llegar a un número de interaciones:
  - Etiquetar cada ejemplo $(i)$, asignándole un grupo $c^{(i)}$.
  - Recalcular los centroides de cada grupo. El nuevo valor de un centroide $\mu_k$ será el centro de masa de los ejemplos etiquetados con $k$ ($c^{(i)}=k$).

Si un grupo $k$ no tiene ejemplos tras alguna iteración, lo podemos eliminar.


*** Optimization objective

La función que estamos optimizando es:

\[ J(c^{(1)}, \dots, c^{(m)} , \mu_1, \dots, \mu_k ) = \frac{1}{m} \sum_1^m || x^{(i)} - \mu_{c^{(i)}} ||^2 \]

Es conocida como /distorsión/ del algoritmo /K-means/.

El algoritmo primero optimiza $c$, manteniendo $\mu$ constante, y después lo hace a la inversa.

*No es una función convexa*, lo que implica que podemos tener más de un mínimo.

La función de costo _debe_ disminuir en cada iteración.

*** Random initialization

La configuración óptima que encontremos al minimizar se ve influenciada por cómo inicializamos los centroides. La forma recomendada es asignarles la posición de un ejemplo cualquiera (distinto a cada uno).

Para buscar la solución global, ejecutamos el algoritmo muchas veces y nos quedamos con aquella solución de menor distorsión.

 - Es importante hacer esto cuando K es chico (Andrew dice 2 a 10), pero no tan necesario cuando estamos buscando muchos grupos.

*** Choosing the number of clusters

*La función de costo debe disminuir a medida que incrementamos K*, llegando al mínimo cuando $K=m$. Si no ocurre para un cierto $K$, es que tuvimos un resultado de un mínimo local no bueno.

El número se suele elegir a ojo, observando los datos, o está determinado por el problema en el cuál vamos a usar nuestro agrupamiento.

Una forma de elegir el número de grupos es con el "método del codo". Este consiste en graficar la función de costo según el valor de $K$, y elegir el vértice de la gráfica descendente. Si no hay vértice claramente observable, entonces no nos sirve el método.

** Review

*** Quiz: Unsuperised learning

** Dimensionality reduction

*** Motivation

**** Motivation I: Data compression

Otro tipo de aprendizaje no supervisado se usa para reducir la dimensionalidad de nuestro universo representado. Esto es, representar la misma información pero con menos descriptores. Esto nos va a permitir tener representaciones más compactas (menos memoria) y sobre todo, acelerar la búsqueda de soluciones.

**** Motivation II Visualization

Otro aplicación de la reducción de dimensionalidad es para intentar visualizar nuestros datos. La visualización suele ayudarnos a entender los datos y proponer mejores soluciones.

*** Principal component analysis

**** Principal component analysis formulation

*Acá trabajamos los ejemplos en sus $n$ dimensiones originales; no agregamos el $x_0=1$ que nos facilitaba trabajar con los interceptos.*

El algoritmo más usado para reducción dimensional es el llamado "Análisis de componentes principales" (/Principal Component Analysis, PCA/). Para el (hiper)espacio de representación de nuestros descriptores, /PCA/ busca determinar el hiperplano que minimice las distancias entre los puntos en el hiperespacio y sus proyecciones (ortogonales) en el hiperplano.

**** Principal component analysis algorithm

No vamos a ver demostraciones, pero la cosa es más o menos así.

Primero debemos normalizar/escalar los valores de entrada, para que estén en dimensiones comparables.

Luego construimos la matriz de covarianza, que tiene las covarianzas de las dimensiones. // La [[https://en.wikipedia.org/wiki/Covariance][covarianza]] indica dependencia entre dimensiones. Si la covarianza es 0, las dimensiones son independientes.

\[ \Sigma = \frac{1}{m} \sum_{i=1}^m x^{(i)} (x^{(i)})^T = \frac{1}{m} X^T X \]

Ahora aplicamos la Descomposición en valores singulares (/SVD, Singular Value Decomposition/), que es una factorización que nos permite obtener los vectores propios o autovectores de la matriz de covarianza.

\[ U_{m \times k}, S, V = svd(\Sigma)  \]

Nos importa la matriz $U$, que tiene autovectores. Cada columna es un autovector, y estos son las dimensiones (¿rotadas? distintas.) que ¿mejor? explican nuestros datos. De esta matriz $U$ nos vamos a quedar con los primeros $k$ vectores, que serán nuestro nuevo espacio de representación. Construimos entonces una matriz $U_{reducción}$.

Para expresar los vectores en las nuevas dimensiones, hacemos

\[ z^{(i)} = U_{reducción}^T x^{(i)} \]

O para todos los ejemplos:

\[ Z = U_{reducción}^T X ]\

*** Appliying PCA

**** Reconstruction from compressed representation

Para volver del espacio $R^k$ al $R^n$, usamos la matriz $U$ así:

\[  x_{aprox}^{(i)} = U_{reducción}  x^{(i)} \]

- Nótese que lo que obtenemos es una aproximación de el dato original. Esta aproximación es la proyección del dato original en el hiperplano de menor dimensión calculado con /PCA/, pero expresado en las $n$ dimensiones originales.
  - Perdemos información.

**** Choosing the number of principal components

Sean

- Error medio de proyección: \( E_{p} = \frac{1}{m} \sum_{i=1}^{m} || x^{(i)} - x_{aprox}^{(i)} ||^2 \)
- Varianza de los datos: \( V = \frac{1}{m} \sum_{i=1}^{m} ||x^{(i)}||^2  \)

Podemos definir la varianza no explicada / no retenida por nuestro modelo de dimensiones reducidas como

\[ V_{ne} = \frac{\frac{1}{m} \sum_{i=1}^{m} || x^{(i)} - x_{aprox}^{(i)} ||^2}{\frac{1}{m} \sum_{i=1}^{m} ||x^{(i)}||^2}  \]

\[ V_{ne} = \frac{\sum_{i=1}^{m} || x^{(i)} - x_{aprox}^{(i)} ||^2}{\sum_{i=1}^{m} ||x^{(i)}||^2}  \]

- Normalmente buscamos que $V_{ne}$ sea menor al $5%$ o $1%$, pero depende del caso.
- En modelos de alta dimensionalidad es frecuente encontrar que muchas dimensiones están correlacionadas y por tanto podemos encontrar un $k\ll n$.

Para calcular $V_{ne}$ como lo definimos anteriormente, debemos hacer todo el proceso de /PCA/ para un $k$ dado, para luego calcular los errores de proyección. Esto es costoso.

Una mejor forma de hacerlo es con la matriz $S$ obtenida al hacer /SVD/:

\[ U_{m \times k}, S, V = svd(\Sigma)  \]

Esta tiene (en su diagonal principal) los autovalores $s_{ii}$ asociados con los autovectores de $U$, y al igual que estos, están ordenados de mayor a menor importancia o influencia. Podemos hacer entonces:

\[ V_{ne} = 1 - \frac{ \sum_{i=1}^k s_{ii} }{ \sum_{i=1}^n s_{ii} } \]

y fácilmente definimos el $k$ que queremos.


**** Advice for appliying PCA

Algunos consejos:

1. *No* usar /PCA/ como herramienta para reducir sobreajuste. Puede funcionar, pero al usar /PCA/ no estamos teniendo en cuenta las etiquetas de los datos de entrada, y quizás estamos desechando información importante, o grupos enteros de datos. La regulrización es el método que deberíamos usar en su lugar.
2. No usar /PCA/ de entrada, por que sí. Deberíamos siempre probar con los datos crudos, y usar /PCA/ si queremos acelerar el aprendizaje o usar menos espacio, por ejemplo.

*** Review

**** Quiz: principal component analysis

**** Programming assignment: K-means clustering and PCA

